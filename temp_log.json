[2025-12-12 18:46:53,495] INFO service.qa: {"query": "새로운 서버 생성하는 법 알려줘", "provider": "local", "top_k": 8, "citations": [{"ref": "/docs/aws-cli_pdf_cli-chap-welcome.pdf", "chunk_id": "aws/aws-cli_pdf_cli-chap-welcome_pdf#chunk561", "doc_id": "aws/aws-cli_pdf_cli-chap-welcome_pdf", "page": 3467, "anchor": "{ \"resourceType\": \"aws:ec2:instance\", \"resourceArns\": [ \"arn:aws:ec2:us-west-2:123456789012:instance/ i-12a3b4c56d78e9012\" ], \"selectionMode\": \"ALL\" } }, \"actions\": { \"reboot\": { \"actionId\": \"aws:ec2:reboot-instances\", \"parameters\": {}, \"targets\": { \"Instances\": \"Instances-Target-1\" }, \"startAfter\": [ \"wait\" ], \"state\": { \"status\": \"pending\", \"reason\": \"Initial state.\" } }, \"wait\": { \"actionId\": \"aws:fis:wait\", \"parameters\": { \"duration\": \"PT5M\" }, \"state\": { \"status\": \"running\", \"reason\": \"\" AWS FIS 3445\n\n 버전 2 사용 설명서 AWS Command Line Interface } } }, \"stopConditions\": [ { \"source\": \"none\" } ], \"creationTime\": 1616432680.927, \"startTime\": 1616432681.177, \"tags\": {} } } 자세한 내용은 AWS Fault Injection Simulator 사용 설명서의 Experiments for AWS FIS을 참조하세 요. • API 세부 정보는 AWS CLI 명령 참조의 StopExperiment를 참조하세요. tag-resource 다음 코드 예시는 tag-resource의 사용 방법을 보여 줍니다. AWS CLI 리소스에 태그를 지정하려면 다음 tag-resource 예제에서는 지정된 리소스에 태그를 지정합니다. aws fis tag-resource \\ --resource-arn arn:aws:fis:us-west-2:123456789012:experiment/ABC12DeFGhI3jKLMNOP \\ --tags key1=value1,key2=value2 이 명령은 출력을 생성하지 않습니다. 자세한 내용은 AWS Fault Injection Simulator 사용 설명서의 Tag your AWS FIS resources를 참조 하세요. • API 세부 정보는 AWS CLI 명령 참조의 TagResource를 참조하세요. AWS FIS 3446\n\n AWS Command Line Interface untag-resource 버전 2 사용 설명서 다음 코드 예시에서는 untag-resource 코드를 사용하는 방법을 보여줍니다. AWS CLI 리소스에서 태그를 제거하는 방법 다음 untag-resource 예제에서는 지정된 리소스에서 태그를 제거합니다. aws fis untag-resource \\ --resource-arn arn:aws:fis:us-west-2:123456789012:experiment/ABC12DeFGhI3jKLMNOP 이 명령은 출력을 생성하지 않습니다. 자세한 내용은 AWS Fault Injection Simulator 사용 설명서의 Tag your AWS FIS resources를 참조 하세요. • API 세부 정보는 AWS CLI 명령 참조의 UntagResource를 참조하세요. update-experiment-template 다음 코드 예시는 update-experiment-template의 사용 방법을 보여 줍니다. AWS CLI 실험 템플릿을 업데이트하는 방법 다음 update-experiment-template 예제에서는 지정된 실험 템플릿의 설명을 업데이트합니 다. aws fis update-experiment-template \\ --id ABCDE1fgHIJkLmNop \\ ---description myExperimentTemplate 출력: { \"experimentTemplate\": { \"id\": \"ABCDE1fgHIJkLmNop\", \"description\": \"myExperimentTemplate\", \"targets\": { \"Instances-Target-1\": { AWS FIS 3447\n\n AWS Command Line Interface 버전 2 사용 설명서 \"resourceType\": \"aws:ec2:instance\", \"resourceArns\": [ \"arn:aws:ec2:us-west-2:123456789012:instance/ i-12a3b4c56d78e9012\" ], \"selectionMode\": \"ALL\" } }, \"actions\": { \"testaction\": { \"actionId\": \"aws:ec2:stop-instances\", \"parameters\": {}, \"targets\": { \"Instances\": \"Instances-Target-1\" } } }, \"stopConditions\": [ { \"source\": \"none\" } ], \"creationTime\": 1616017191.124, \"lastUpdateTime\": 1616017859.607, \"roleArn\": \"arn:aws:iam::123456789012:role/FISRole\", \"tags\": { \"key\": \"value\" } } } 자세한 내용은 AWS Fault Injection Simulator 사용 설명서의 Update an experiment template을 참 조하세요. • API 세부 정보는 AWS CLI 명령 참조의 UpdateExperimentTemplate을 참조하세요. AWS CLI를 사용한 Amazon GameLift Servers 예제 다음 코드 예제에서는 Amazon GameLift Servers에서 AWS Command Line Interface를 사용하여 일반 적인 시나리오를 구현하는 방법을 보여줍니다. 작업은 대규모 프로그램에서 발췌한 코드이며 컨텍스트에 맞춰 실행해야 합니다. 작업은 관련 시나리 오의 컨텍스트에 따라 표시되며, 개별 서비스 함수를 직접적으로 호출하는 방법을 보여줍니다. Amazon GameLift Servers 3448\n\n AWS Command Line Interface 버전 2 사용 설명서 각 예시에는 전체 소스 코드에 대한 링크가 포함되어 있으며, 여기에서 컨텍스트에 맞춰 코드를 설정하 고 실행하는 방법에 대한 지침을 찾을 수 있습니다. 주제 • 작업 작업 create-build 다음 코드 예시에서는 create-build 코드를 사용하는 방법을 보여줍니다. AWS CLI 예시 1: S3 버킷의 파일에서 게임 빌드를 생성하는 방법 다음 create-build 예시에서는 사용자 지정 게임 빌드 리소스를 생성합니다. 사용자가 제어하는 AWS 계정의 S3 위치에 저장된 압축 파일을 사용합니다. 이 예시에서는 Amazon GameLift에 S3 위 치에 액세스할 수 있는 권한을 부여하는 IAM 역할을 이미 생성했다고 가정합니다. 요청에 운영 체 제가 지정되지 않았으므로 새 빌드 리소스는 기본적으로 WINDOWS_2012로 설정됩니다. aws gamelift create-build \\ --storage-location file://storage-loc.json \\ --name MegaFrogRaceServer.NA \\ --build-version 12345.678 storage-loc.json의 콘텐츠: { \"Bucket\":\"MegaFrogRaceServer_NA_build_files\" \"Key\":\"MegaFrogRaceServer_build_123.zip\" \"RoleArn\":\"arn:aws:iam::123456789012:role/gamelift\" } 출력: { \"Build\": { \"BuildArn\": \"arn:aws:gamelift:us-west-2::build/build-a1b2c3d4-5678-90ab- cdef-EXAMPLE11111\", Amazon GameLift Servers 3449\n\n AWS Command Line Interface 버전 2 사용 설명서 \"BuildId\": \"build-a1b2c3d4-5678-90ab-cdef-EXAMPLE11111\", \"CreationTime\": 1496708916.18, \"Name\": \"MegaFrogRaceServer.NA\", \"OperatingSystem\": \"WINDOWS_2012\", \"SizeOnDisk\": 479303, \"Status\": \"INITIALIZED\", \"Version\": \"12345.678\" }, \"StorageLocation\": { \"Bucket\": \"MegaFrogRaceServer_NA_build_files\", \"Key\": \"MegaFrogRaceServer_build_123.zip\" } } 예시 2: GameLift에 파일을 수동으로 업로드하기 위한 게임 빌드 리소스를 생성하는 방법 다음 create-build 예시에서는 새로운 빌드 리소스를 생성합니다. 또한 게임 빌드를 Amazon S3 의 GameLift 위치에 수동으로 업로드할 수 있는 스토리지 위치와 임시 자격 증명을 얻습니다. 빌드 를 성공적으로 업로드하면 GameLift 서비스에서 빌드의 유효성을 검사하고 새 빌드의 상태를 업데 이트합니다. aws gamelift create-build \\ --name MegaFrogRaceServer.NA \\ --build-version 12345.678 \\ --operating-system AMAZON_LINUX 출력: { \"Build\": { \"BuildArn\": \"arn:aws:gamelift:us-west-2::build/build-a1b2c3d4-5678-90ab- cdef-EXAMPLE11111\", \"BuildId\": \"build-a1b2c3d4-5678-90ab-cdef-EXAMPLE11111\", \"CreationTime\": 1496708916.18, \"Name\": \"MegaFrogRaceServer.NA\", \"OperatingSystem\": \"AMAZON_LINUX\", \"SizeOnDisk\": 0, \"Status\": \"INITIALIZED\", \"Version\": \"12345.678\" }, \"StorageLocation\": { \"Bucket\": \"gamelift-builds-us-west-2\", Amazon GameLift Servers 3450\n\n AWS Command Line Interface 버전 2 사용 설명서 \"Key\": \"123456789012/build-a1b2c3d4-5678-90ab-cdef-EXAMPLE11111\" }, \"UploadCredentials\": { \"AccessKeyId\": \"AKIAIOSFODNN7EXAMPLE\", \"SecretAccessKey\": \"wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY\", \"SessionToken\": \"AgoGb3JpZ2luENz...EXAMPLETOKEN==\" } } 자세한 내용은 Amazon GameLift 개발자 안내서의 Upload a Custom Server Build to GameLift를 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 CreateBuild 섹션을 참조하세요. create-fleet 다음 코드 예시에서는 create-fleet 코드를 사용하는 방법을 보여줍니다. AWS CLI 예시 1: 기본 Linux 플릿 생성 다음 create-fleet 예시는 사용자 지정 서버 빌드를 호스팅하기 위해 최소한의 온디맨드 Linux 인스턴스로 구성된 플릿을 생성합니다. update-fleet 명령을 사용하여 이를 확인할 수 있습니 다. aws gamelift create-fleet \\ --name MegaFrogRaceServer.NA.v2 \\ --description 'Hosts for v2 North America' \\ --build-id build-1111aaaa-22bb-33cc-44dd-5555eeee66ff \\ --certificate-configuration 'CertificateType=GENERATED' \\ --ec2-instance-type c4.large \\ --fleet-type ON_DEMAND \\ --runtime-configuration 'ServerProcesses=[{LaunchPath=/local/game/release-na/ MegaFrogRace_Server.exe,ConcurrentExecutions=1}]' 출력: { \"FleetAttributes\": { \"BuildId\": \"build-1111aaaa-22bb-33cc-44dd-5555eeee66ff\", \"CertificateConfiguration\": { Amazon GameLift Servers 3451\n\n AWS Command Line Interface 버전 2 사용 설명서 \"CertificateType\": \"GENERATED\" }, \"CreationTime\": 1496365885.44, \"Description\": \"Hosts for v2 North America\", \"FleetArn\": \"arn:aws:gamelift:us-west-2:444455556666:fleet/ fleet-2222bbbb-33cc-44dd-55ee-6666ffff77aa\", \"FleetId\": \"fleet-2222bbbb-33cc-44dd-55ee-6666ffff77aa\", \"FleetType\": \"ON_DEMAND\", \"InstanceType\": \"c4.large\", \"MetricGroups\": [\"default\"], \"Name\": \"MegaFrogRace.NA.v2\", \"NewGameSessionProtectionPolicy\": \"NoProtection\", \"OperatingSystem\": \"AMAZON_LINUX\", \"ServerLaunchPath\": \"/local/game/release-na/MegaFrogRace_Server.exe\", \"Status\": \"NEW\" } } 예시 2: 기본 Windows 플릿 생성 다음 create-fleet 예시는 사용자 지정 서버 빌드를 호스팅하기 위해 최소한의 스팟 Windows 인스턴스로 구성된 플릿을 생성합니다. update-fleet 명령을 사용하여 이를 확인할 수 있습니 다. aws gamelift create-fleet \\ --name MegaFrogRace.NA.v2 \\ --description 'Hosts for v2 North America' \\ --build-id build-2222aaaa-33bb-44cc-55dd-6666eeee77ff \\ --certificate-configuration\n\n호스팅하기 위해 최소한의 온디맨드 Linux 인스턴스로 구성된 플릿을 생성합니다. update-fleet 명령을 사용하여 이를 확인할 수 있습니 다. aws gamelift create-fleet \\ --name MegaFrogRaceServer.NA.v2 \\ --description 'Hosts for v2 North America' \\ --build-id build-1111aaaa-22bb-33cc-44dd-5555eeee66ff \\ --certificate-configuration 'CertificateType=GENERATED' \\ --ec2-instance-type c4.large \\ --fleet-type ON_DEMAND \\ --runtime-configuration 'ServerProcesses=[{LaunchPath=/local/game/release-na/ MegaFrogRace_Server.exe,ConcurrentExecutions=1}]' 출력: { \"FleetAttributes\": { \"BuildId\": \"build-1111aaaa-22bb-33cc-44dd-5555eeee66ff\", \"CertificateConfiguration\": { Amazon GameLift Servers 3451\n\n AWS Command Line Interface 버전 2 사용 설명서 \"CertificateType\": \"GENERATED\" }, \"CreationTime\": 1496365885.44, \"Description\": \"Hosts for v2 North America\", \"FleetArn\": \"arn:aws:gamelift:us-west-2:444455556666:fleet/ fleet-2222bbbb-33cc-44dd-55ee-6666ffff77aa\", \"FleetId\": \"fleet-2222bbbb-33cc-44dd-55ee-6666ffff77aa\", \"FleetType\": \"ON_DEMAND\", \"InstanceType\": \"c4.large\", \"MetricGroups\": [\"default\"], \"Name\": \"MegaFrogRace.NA.v2\", \"NewGameSessionProtectionPolicy\": \"NoProtection\", \"OperatingSystem\": \"AMAZON_LINUX\", \"ServerLaunchPath\": \"/local/game/release-na/MegaFrogRace_Server.exe\", \"Status\": \"NEW\" } } 예시 2: 기본 Windows 플릿 생성 다음 create-fleet 예시는 사용자 지정 서버 빌드를 호스팅하기 위해 최소한의 스팟 Windows 인스턴스로 구성된 플릿을 생성합니다. update-fleet 명령을 사용하여 이를 확인할 수 있습니 다. aws gamelift create-fleet \\ --name MegaFrogRace.NA.v2 \\ --description 'Hosts for v2 North America' \\ --build-id build-2222aaaa-33bb-44cc-55dd-6666eeee77ff \\ --certificate-configuration 'CertificateType=GENERATED' \\ --ec2-instance-type c4.large \\ --fleet-type SPOT \\ --runtime-configuration 'ServerProcesses=[{LaunchPath=C:\\game \\Bin64.Release.Dedicated\\MegaFrogRace_Server.exe,ConcurrentExecutions=1}]' 출력: { \"FleetAttributes\": { \"BuildId\": \"build-2222aaaa-33bb-44cc-55dd-6666eeee77ff\", \"CertificateConfiguration\": { \"CertificateType\": \"GENERATED\" }, Amazon GameLift Servers 3452\n\n AWS Command Line Interface 버전 2 사용 설명서 \"CreationTime\": 1496365885.44, \"Description\": \"Hosts for v2 North America\", \"FleetArn\": \"arn:aws:gamelift:us-west-2:444455556666:fleet/ fleet-2222bbbb-33cc-44dd-55ee-6666ffff77aa\", \"FleetId\": \"fleet-2222bbbb-33cc-44dd-55ee-6666ffff77aa\", \"FleetType\": \"SPOT\", \"InstanceType\": \"c4.large\", \"MetricGroups\": [\"default\"], \"Name\": \"MegaFrogRace.NA.v2\", \"NewGameSessionProtectionPolicy\": \"NoProtection\", \"OperatingSystem\": \"WINDOWS_2012\", \"ServerLaunchPath\": \"C:\\game\\Bin64.Release.Dedicated \\MegaFrogRace_Server.exe\", \"Status\": \"NEW\" } } 예시 3: 완전히 구성된 플릿 생성 다음 create-fleet 예시는 사용자 지정 서버 빌드를 위한 스팟 Windows 인스턴스 플릿을 생성 하며, 가장 일반적으로 사용되는 구성 설정이 제공됩니다 aws gamelift create-fleet \\ --name MegaFrogRace.NA.v2 \\ --description 'Hosts for v2 North America' \\ --build-id build-2222aaaa-33bb-44cc-55dd-6666eeee77ff \\ --certificate-configuration 'CertificateType=GENERATED' \\ --ec2-instance-type c4.large \\ --ec2-inbound-permissions 'FromPort=33435,ToPort=33435,IpRange=10.24.34.0/23,Protocol=UDP' \\ --fleet-type SPOT \\ --new-game-session-protection-policy FullProtection \\ --runtime-configuration file://runtime-config.json \\ --metric-groups default \\ --instance-role-arn 'arn:aws:iam::444455556666:role/GameLiftS3Access' runtime-config.json의 콘텐츠: GameSessionActivationTimeoutSeconds=300, MaxConcurrentGameSessionActivations=2, ServerProcesses=[ {LaunchPath=C:\\game\\Bin64.Release.Dedicated\\MegaFrogRace_Server.exe,Parameters=- debug,ConcurrentExecutions=1}, Amazon GameLift Servers 3453\n\n AWS Command Line Interface 버전 2 사용 설명서 {LaunchPath=C:\\game\\Bin64.Release.Dedicated \\MegaFrogRace_Server.exe,ConcurrentExecutions=1}] 출력: { \"FleetAttributes\": { \"InstanceRoleArn\": \"arn:aws:iam::444455556666:role/GameLiftS3Access\", \"Status\": \"NEW\", \"InstanceType\": \"c4.large\", \"FleetArn\": \"arn:aws:gamelift:us-west-2:444455556666:fleet/ fleet-2222bbbb-33cc-44dd-55ee-6666ffff77aa\", \"FleetId\": \"fleet-2222bbbb-33cc-44dd-55ee-6666ffff77aa\", \"Description\": \"Hosts for v2 North America\", \"FleetType\": \"SPOT\", \"OperatingSystem\": \"WINDOWS_2012\", \"Name\": \"MegaFrogRace.NA.v2\", \"CreationTime\": 1569309011.11, \"MetricGroups\": [ \"default\" ], \"BuildId\": \"build-2222aaaa-33bb-44cc-55dd-6666eeee77ff\", \"ServerLaunchParameters\": \"abc\", \"ServerLaunchPath\": \"C:\\\\game\\\\Bin64.Release.Dedicated\\ \\MegaFrogRace_Server.exe\", \"NewGameSessionProtectionPolicy\": \"FullProtection\", \"CertificateConfiguration\": { \"CertificateType\": \"GENERATED\" } } } 예시 4: Realtime Servers 플릿 생성 다음 create-fleet 예시에서는 Amazon GameLift에 업로드된 Realtime 구성 스크립트를 사용하 여 스팟 인스턴스 플릿을 생성합니다. 모든 Realtime Servers는 Linux 머신에 배포됩니다. 이 예시 에서는 업로드된 Realtime 스크립트에 여러 스크립트 파일이 포함되어 있고 Init() 함수는 스크 립트 파일에 있는 MainScript.js로 가정합니다. 그림과 같이 이 파일은 런타임 구성에서 시작 스 크립트로 식별됩니다. aws gamelift create-fleet \\ --name MegaFrogRace.NA.realtime \\ Amazon GameLift Servers 3454\n\n AWS Command Line Interface 버전 2 사용 설명서 --description 'Mega Frog Race Realtime fleet' \\ --script-id script-1111aaaa-22bb-33cc-44dd-5555eeee66ff \\ --ec2-instance-type c4.large \\ --fleet-type SPOT \\ --certificate-configuration 'CertificateType=GENERATED' --runtime-configuration 'ServerProcesses=[{LaunchPath=/local/game/MainScript.js,Parameters=+map Winter444,ConcurrentExecutions=5}]' 출력: { \"FleetAttributes\": { \"FleetId\": \"fleet-2222bbbb-33cc-44dd-55ee-6666ffff77aa\", \"Status\": \"NEW\", \"CreationTime\": 1569310745.212, \"InstanceType\": \"c4.large\", \"NewGameSessionProtectionPolicy\": \"NoProtection\", \"CertificateConfiguration\": { \"CertificateType\": \"GENERATED\" }, \"Name\": \"MegaFrogRace.NA.realtime\", \"ScriptId\": \"script-1111aaaa-22bb-33cc-44dd-5555eeee66ff\", \"FleetArn\": \"arn:aws:gamelift:us-west-2:444455556666:fleet/ fleet-2222bbbb-33cc-44dd-55ee-6666ffff77aa\", \"FleetType\": \"SPOT\", \"MetricGroups\": [ \"default\" ], \"Description\": \"Mega Frog Race Realtime fleet\", \"OperatingSystem\": \"AMAZON_LINUX\" } } • API 세부 정보는 AWS CLI 명령 참조의 CreateFleet 섹션을 참조하세요. create-game-session-queue 다음 코드 예시에서는 create-game-session-queue 코드를 사용하는 방법을 보여줍니다. AWS CLI 예시 1: 순서가 지정된 게임 세션 대기열을 설정하는 방법 Amazon GameLift Servers 3455\n\n AWS Command Line Interface 버전 2 사용 설명서 다음 create-game-session-queue 예시에서는 두 리전의 대상으로 새 게임 세션 대기열을 생 성합니다. 또한 게임 세션 요청이 10분 동안 대기한 후 시간 초과되도록 대기열을 구성합니다. 지연 시간 정책이 정의되어 있지 않으므로 GameLift는 모든 게임 세션을 첫 번째 대상에 배치하려고 시 도합니다. aws gamelift create-game-session-queue \\ --name MegaFrogRaceServer-NA \\ --destinations file://destinations.json \\ --timeout-in-seconds 600 destinations.json의 콘텐츠: { \"Destinations\": [ {\"DestinationArn\": \"arn:aws:gamelift:us-west-2::fleet/fleet- a1b2c3d4-5678-90ab-cdef-EXAMPLE11111\" }, {\"DestinationArn\": \"arn:aws:gamelift:us-west-1::fleet/fleet- a1b2c3d4-5678-90ab-cdef-EXAMPLE22222\" } ] } 출력: { \"GameSessionQueues\": [ { \"Name\": \"MegaFrogRaceServer-NA\", \"GameSessionQueueArn\": \"arn:aws:gamelift:us- west-2:123456789012:gamesessionqueue/MegaFrogRaceServer-NA\", \"TimeoutInSeconds\": 600, \"Destinations\": [ {\"DestinationArn\": \"arn:aws:gamelift:us-west-2::fleet/fleet- a1b2c3d4-5678-90ab-cdef-EXAMPLE11111\"}, {\"DestinationArn\": \"arn:aws:gamelift:us-west-1::fleet/fleet- a1b2c3d4-5678-90ab-cdef-EXAMPLE22222\"} ] } ] } 예시 2: 플레이어 지연 시간 정책을 사용하여 게임 세션 대기열을 설정하는 방법 Amazon GameLift Servers 3456\n\n AWS Command Line Interface 버전 2 사용 설명서 다음 create-game-session-queue 예시에서는 두 개의 플레이어 지연 시간 정책을 사용하여 새 게임 세션 대기열을 생성합니다. 첫 번째 정책은 게임 세션 배치 시도의 첫 1분 동안 적용되는 지 연 시간 제한을 100ms로 설정합니다. 두 번째 정책은 배치 요청이 3분으로 제한될 때까지 지연 시 간 한도를 200ms로 높입니다. aws gamelift create-game-session-queue \\ --name MegaFrogRaceServer-NA \\ --destinations file://destinations.json \\ --player-latency-policies file://latency-policies.json \\ --timeout-in-seconds 180 destinations.json의 콘텐츠: { \"Destinations\": [ { \"DestinationArn\": \"arn:aws:gamelift:us-west-2::fleet/fleet- a1b2c3d4-5678-90ab-cdef-EXAMPLE11111\" }, { \"DestinationArn\": \"arn:aws:gamelift:us-east-1::fleet/fleet- a1b2c3d4-5678-90ab-cdef-EXAMPLE22222\" } ] } latency-policies.json의 콘텐츠: { \"PlayerLatencyPolicies\": [ {\"MaximumIndividualPlayerLatencyMilliseconds\": 200}, {\"MaximumIndividualPlayerLatencyMilliseconds\": 100, \"PolicyDurationSeconds\": 60} ] } 출력: { \"GameSessionQueue\": { \"Name\": \"MegaFrogRaceServer-NA\", \"GameSessionQueueArn\": \"arn:aws:gamelift:us- west-2:111122223333:gamesessionqueue/MegaFrogRaceServer-NA\", \"TimeoutInSeconds\": 600, \"PlayerLatencyPolicies\": [ Amazon GameLift Servers 3457\n\n AWS Command Line Interface { 버전 2 사용 설명서 \"MaximumIndividualPlayerLatencyMilliseconds\": 100, \"PolicyDurationSeconds\": 60 }, { \"MaximumIndividualPlayerLatencyMilliseconds\": 200 } ] \"Destinations\": [ {\"DestinationArn\": \"arn:aws:gamelift:us-west-2::fleet/fleet- a1b2c3d4-5678-90ab-cdef-EXAMPLE11111\"}, {\"DestinationArn\": \"arn:aws:gamelift:us-east-1::fleet/fleet- a1b2c3d4-5678-90ab-cdef-EXAMPLE22222\"} ], } } 자세한 내용은 Amazon GameLift 개발자 안내서의 Create a Queue를 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 CreateGameSessionQueue 섹션을 참조하세요. delete-build 다음 코드 예시에서는 delete-build 코드를 사용하는 방법을 보여줍니다. AWS CLI 사용자 지정 게임 빌드를 삭제하는 방법 다음 delete-build 예시에서는 Amazon GameLift 계정에서 빌드를 제거합니다. 빌드가 삭제된 후에는 새 플릿을 만드는 데 사용할 수 없습니다. 이 작업은 실행 취소할 수 없습니다. aws gamelift delete-build \\ --build-id build-a1b2c3d4-5678-90ab-cdef-EXAMPLE11111 이 명령은 출력을 생성하지 않습니다. • API 세부 정보는 AWS CLI 명령 참조의 DeleteBuild 섹션을 참조하세요. delete-fleet 다음 코드 예시에서는 delete-fleet 코드를 사용하는 방법을 보여줍니다. Amazon GameLift Servers 3458\n\n AWS Command Line\n\n{ \"GameSessionQueue\": { \"Name\": \"MegaFrogRaceServer-NA\", \"GameSessionQueueArn\": \"arn:aws:gamelift:us- west-2:111122223333:gamesessionqueue/MegaFrogRaceServer-NA\", \"TimeoutInSeconds\": 600, \"PlayerLatencyPolicies\": [ Amazon GameLift Servers 3457\n\n AWS Command Line Interface { 버전 2 사용 설명서 \"MaximumIndividualPlayerLatencyMilliseconds\": 100, \"PolicyDurationSeconds\": 60 }, { \"MaximumIndividualPlayerLatencyMilliseconds\": 200 } ] \"Destinations\": [ {\"DestinationArn\": \"arn:aws:gamelift:us-west-2::fleet/fleet- a1b2c3d4-5678-90ab-cdef-EXAMPLE11111\"}, {\"DestinationArn\": \"arn:aws:gamelift:us-east-1::fleet/fleet- a1b2c3d4-5678-90ab-cdef-EXAMPLE22222\"} ], } } 자세한 내용은 Amazon GameLift 개발자 안내서의 Create a Queue를 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 CreateGameSessionQueue 섹션을 참조하세요. delete-build 다음 코드 예시에서는 delete-build 코드를 사용하는 방법을 보여줍니다. AWS CLI 사용자 지정 게임 빌드를 삭제하는 방법 다음 delete-build 예시에서는 Amazon GameLift 계정에서 빌드를 제거합니다. 빌드가 삭제된 후에는 새 플릿을 만드는 데 사용할 수 없습니다. 이 작업은 실행 취소할 수 없습니다. aws gamelift delete-build \\ --build-id build-a1b2c3d4-5678-90ab-cdef-EXAMPLE11111 이 명령은 출력을 생성하지 않습니다. • API 세부 정보는 AWS CLI 명령 참조의 DeleteBuild 섹션을 참조하세요. delete-fleet 다음 코드 예시에서는 delete-fleet 코드를 사용하는 방법을 보여줍니다. Amazon GameLift Servers 3458\n\n AWS Command Line Interface AWS CLI 더 이상 사용되지 않는 플릿을 삭제하는 방법 버전 2 사용 설명서 다음 delete-fleet 예시에서는 인스턴스가 0으로 스케일 다운된 플릿을 제거합니다. 플릿 용량 이 0보다 크면 HTTP 400 오류와 함께 요청이 실패합니다. aws gamelift delete-fleet \\ --fleet-id fleet-a1b2c3d4-5678-90ab-cdef-EXAMPLE11111 이 명령은 출력을 생성하지 않습니다. 자세한 내용은 Amazon GameLift 개발자 안내서의 Manage GameLift Fleets를 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 DeleteFleet 섹션을 참조하세요. delete-game-session-queue 다음 코드 예시에서는 delete-game-session-queue 코드를 사용하는 방법을 보여줍니다. AWS CLI 게임 세션 대기열을 삭제하는 방법 다음 delete-game-session-queue 예시에서는 지정된 게임 세션 대기열을 삭제합니다. aws gamelift delete-game-session-queue \\ --name MegaFrogRace-NA 이 명령은 출력을 생성하지 않습니다. • API 세부 정보는 AWS CLI 명령 참조의 DeleteGameSessionQueue 섹션을 참조하세요. describe-build 다음 코드 예시에서는 describe-build 코드를 사용하는 방법을 보여줍니다. AWS CLI 사용자 지정 게임 빌드에 대한 정보를 얻으려면 다음 describe-build 예시에서는 게임 서버 빌드 리소스의 속성을 검색합니다. Amazon GameLift Servers 3459\n\n AWS Command Line Interface 버전 2 사용 설명서 aws gamelift describe-build \\ --build-id build-a1b2c3d4-5678-90ab-cdef-EXAMPLE11111 출력: { \"Build\": { \"BuildArn\": \"arn:aws:gamelift:us-west-2::build/build-a1b2c3d4-5678-90ab- cdef-EXAMPLE11111\", \"BuildId\": \"build-a1b2c3d4-5678-90ab-cdef-EXAMPLE11111\", \"CreationTime\": 1496708916.18, \"Name\": \"My_Game_Server_Build_One\", \"OperatingSystem\": \"AMAZON_LINUX\", \"SizeOnDisk\": 1304924, \"Status\": \"READY\", \"Version\": \"12345.678\" } } 자세한 내용은 Amazon GameLift 개발자 안내서의 Upload a Custom Server Build to GameLift를 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 DescribeBuild 섹션을 참조하세요. describe-ec2-instance-limits 다음 코드 예시에서는 describe-ec2-instance-limits 코드를 사용하는 방법을 보여줍니다. AWS CLI EC2 인스턴스 유형에 대한 서비스 제한을 검색하는 방법 다음 describe-ec2-instance-limits 예시에서는 현재 리전에서 지정된 EC2 인스턴스 유형 에 대해 사용 중인 최대 허용 인스턴스와 현재 인스턴스를 보여줍니다. 그 결과 허용된 20개의 인스 턴스 중 5개만 사용되고 있는 것으로 나타났습니다. aws gamelift describe-ec2-instance-limits \\ --ec2-instance-type m5.large 출력: Amazon GameLift Servers 3460\n\n AWS Command Line Interface 버전 2 사용 설명서 { \"EC2InstanceLimits\": [ { \"EC2InstanceType\": \"\"m5.large\", \"CurrentInstances\": 5, \"InstanceLimit\": 20 } ] } 자세한 내용은 Amazon CloudFront 개발자 안내서의 Choose Computing Resources를 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 DescribeEc2InstanceLimits 섹션을 참조하세요. describe-fleet-attributes 다음 코드 예시에서는 describe-fleet-attributes 코드를 사용하는 방법을 보여줍니다. AWS CLI 예시 1: 플릿 목록의 속성을 보는 방법 다음 describe-fleet-attributes 예시에서는 지정된 두 플릿에 대한 플릿 속성을 검색합니 다. 표시된 바와 같이 요청된 플릿은 동일한 빌드로 배포되며, 하나는 온디맨드 인스턴스용이고 다 른 하나는 스팟 인스턴스용이지만 약간의 구성 차이가 있습니다. aws gamelift describe-fleet-attributes \\ --fleet-ids arn:aws:gamelift:us-west-2::fleet/fleet-a1b2c3d4-5678-90ab-cdef- EXAMPLE11111 fleet-a1b2c3d4-5678-90ab-cdef-EXAMPLE22222 출력: { \"FleetAttributes\": [ { \"FleetId\": \"fleet-a1b2c3d4-5678-90ab-cdef-EXAMPLE11111\", \"FleetArn\": \"arn:aws:gamelift:us-west-2::fleet/fleet-a1b2c3d4-5678-90ab- cdef-EXAMPLE11111\", \"FleetType\": \"ON_DEMAND\", \"InstanceType\": \"c4.large\", \"Description\": \"On-demand hosts for v2 North America\", \"Name\": \"MegaFrogRaceServer.NA.v2-od\", Amazon GameLift Servers 3461\n\n AWS Command Line Interface 버전 2 사용 설명서 \"CreationTime\": 1568836191.995, \"Status\": \"ACTIVE\", \"BuildId\": \"build-a1b2c3d4-5678-90ab-cdef-EXAMPLE33333\", \"BuildArn\": \"arn:aws:gamelift:us-west-2::build/build-a1b2c3d4-5678-90ab- cdef-EXAMPLE33333\", \"ServerLaunchPath\": \"C:\\\\game\\\\MegaFrogRace_Server.exe\", \"ServerLaunchParameters\": \"+gamelift_start_server\", \"NewGameSessionProtectionPolicy\": \"NoProtection\", \"OperatingSystem\": \"WINDOWS_2012\", \"MetricGroups\": [ \"default\" ], \"CertificateConfiguration\": { \"CertificateType\": \"DISABLED\" } }, { \"FleetId\": \"fleet-a1b2c3d4-5678-90ab-cdef-EXAMPLE22222\", \"FleetArn\": \"arn:aws:gamelift:us-west-2::fleet/fleet-a1b2c3d4-5678-90ab- cdef-EXAMPLE22222\", \"FleetType\": \"SPOT\", \"InstanceType\": \"c4.large\", \"Description\": \"On-demand hosts for v2 North America\", \"Name\": \"MegaFrogRaceServer.NA.v2-spot\", \"CreationTime\": 1568838275.379, \"Status\": \"ACTIVATING\", \"BuildId\": \"build-a1b2c3d4-5678-90ab-cdef-EXAMPLE33333\", \"BuildArn\": \"arn:aws:gamelift:us-west-2::build/build-a1b2c3d4-5678-90ab- cdef-EXAMPLE33333\", \"ServerLaunchPath\": \"C:\\\\game\\\\MegaFrogRace_Server.exe\", \"NewGameSessionProtectionPolicy\": \"NoProtection\", \"OperatingSystem\": \"WINDOWS_2012\", \"MetricGroups\": [ \"default\" ], \"CertificateConfiguration\": { \"CertificateType\": \"GENERATED\" } } ] } 예시 2: 모든 플릿에 대한 속성을 요청하는 방법 Amazon GameLift Servers 3462\n\n AWS Command Line Interface 버전 2 사용 설명서 다음 describe-fleet-attributes 예시에서는 모든 상태의 모든 플릿에 대한 플릿 속성을 반 환합니다. 이 예시에서는 페이지 매김 파라미터를 사용하여 한 번에 하나의 플릿을 반환하는 방법 을 설명합니다. aws gamelift describe-fleet-attributes \\ --limit 1 출력: { \"FleetAttributes\": [ { \"FleetId\": \"fleet-a1b2c3d4-5678-90ab-cdef-EXAMPLE22222\", \"FleetArn\": \"arn:aws:gamelift:us-west-2::fleet/fleet-a1b2c3d4-5678-90ab- cdef-EXAMPLE22222\", \"FleetType\": \"SPOT\", \"InstanceType\": \"c4.large\", \"Description\": \"On-demand hosts for v2 North America\", \"Name\": \"MegaFrogRaceServer.NA.v2-spot\", \"CreationTime\": 1568838275.379, \"Status\": \"ACTIVATING\", \"BuildId\": \"build-a1b2c3d4-5678-90ab-cdef-EXAMPLE33333\", \"BuildArn\": \"arn:aws:gamelift:us-west-2::build/build-a1b2c3d4-5678-90ab- cdef-EXAMPLE33333\", \"ServerLaunchPath\": \"C:\\\\game\\\\MegaFrogRace_Server.exe\", \"NewGameSessionProtectionPolicy\": \"NoProtection\", \"OperatingSystem\": \"WINDOWS_2012\", \"MetricGroups\": [ \"default\" ], \"CertificateConfiguration\": { \"CertificateType\": \"GENERATED\" } } ], \"NextToken\": \"eyJhd3NBY2NvdW50SWQiOnsicyI6IjMwMjc3NjAxNjM5OCJ9LCJidWlsZElkIjp7InMiOiJidWlsZC01NWYxZTZmMS1jY2FlLTQ3YTctOWI5ZS1iYjFkYTQwMjEXAMPLE2\" } 출력에는 명령을 두 번째로 호출할 때 사용할 수 있는 NextToken 값이 포함됩니다. 값을 --next- token 파라미터에 전달하여 출력을 선택할 위치를 지정합니다. 다음 명령은 출력에 두 번째 결과 를 반환합니다. Amazon GameLift Servers 3463\n\n AWS Command Line Interface 버전 2 사용 설명서 aws gamelift describe-fleet-attributes \\ --limit 1 \\ --next- token eyJhd3NBY2NvdW50SWQiOnsicyI6IjMwMjc3NjAxNjM5OCJ9LCJidWlsZElkIjp7InMiOiJidWlsZC01NWYxZTZmMS1jY2FlLTQ3YTctOWI5ZS1iYjFkYTQwMjEXAMPLE1 응답에 NextToken 값이 포함되지 않을 때까지 반복합니다. 자세한 내용은 Amazon GameLift 개발자 안내서의 Setting Up GameLift Fleets를 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 DescribeFleetAttributes 섹션을 참조하세요. describe-fleet-capacity 다음 코드 예시에서는 describe-fleet-capacity 코드를 사용하는 방법을 보여줍니다. AWS CLI 플릿 목록의 용량 상태를 보는 방법 다음 describe-fleet-capacity 예시는 지정된 두 개의 플릿에 대한 현재 용량을 검색합니다. aws gamelift describe-fleet-capacity \\ --fleet-ids arn:aws:gamelift:us-west-2::fleet/fleet-a1b2c3d4-5678-90ab-cdef- EXAMPLE11111 fleet-a1b2c3d4-5678-90ab-cdef-EXAMPLE22222 출력: { \"FleetCapacity\": [ { \"FleetId\": \"fleet-a1b2c3d4-5678-90ab-cdef-EXAMPLE11111\", \"InstanceType\": \"c5.large\", \"InstanceCounts\": { \"DESIRED\": 10, \"MINIMUM\": 1, \"MAXIMUM\": 20, \"PENDING\": 0, \"ACTIVE\": 10, \"IDLE\": 3, \"TERMINATING\": 0 } }, { Amazon GameLift Servers 3464\n\n AWS Command Line Interface 버전 2 사용 설명서 \"FleetId\": \"fleet-a1b2c3d4-5678-90ab-cdef-EXAMPLE22222\", \"InstanceType\": \"c5.large\", \"InstanceCounts\":"}, {"ref": "/docs/rds-ug.pdf", "chunk_id": "aws/rds-ug_pdf#chunk496", "doc_id": "aws/rds-ug_pdf", "page": 2083, "anchor": "Amazon Relational Database Service 사용 설명서 • 5단계: RDS Custom for SQL Server DB 인스턴스 생성 또는 수정 • 6단계: Windows 인증 SQL Server 로그인 생성 • 7단계: Kerberos 또는 NTLM 인증 사용 1단계: AD에서 조직 단위(OU) 생성 다음 단계에 따라 AD에서 조직 단위를 생성합니다. AD에서 OU 생성 1. 도메인 관리자로 도메인 AD에 연결합니다. 2. Active Directory 사용자 및 컴퓨터를 열고 OU를 생성할 도메인을 선택합니다. 3. 도메인을 마우스 오른쪽 버튼으로 클릭하고 새로 만들기를 선택한 다음 조직 단위를 선택합니다. 4. OU 이름을 입력합니다. 컨테이너가 실수로 삭제되지 않도록 보호를 활성화합니다. 5. 확인을 선택합니다. 새 OU는 도메인 아래에 표시됩니다. AWS Managed Microsoft AD의 경우 이 OU의 이름은 디렉터리 생성 시 입력한 NetBIOS 이름에 근거 를 둡니다. 이 OU는 AWS가 소유하며, 전체 제어 권한을 부여한 모든 AWS 관련 디렉터리 객체가 포함 됩니다. 기본적으로 이 OU에는 컴퓨터와 사용자라는 두 개의 하위 OU가 있습니다. RDS Custom이 생 성하는 새 OU는 NetBIOS를 기반으로 하는 OU의 하위 OU입니다. 2단계: AD 도메인 사용자 생성 도메인 사용자 보안 인증 정보는 Secrets Manager에서 보안 암호로 사용됩니다. AD에서 AD 도메인 사용자 생성 1. Active Directory 사용자 및 컴퓨터를 열고 사용자를 생성할 도메인과 OU를 선택합니다. 2. 사용자 객체를 마우스 오른쪽 버튼으로 클릭하고 새로 만들기, 사용자 순으로 선택합니다. 3. 사용자의 이름, 성 및 로그인 이름을 입력합니다. 다음을 클릭합니다. 4. 사용자의 암호를 입력합니다. 다음 로그인 시 사용자가 암호를 변경해야 함 또는 계정이 비활성화 됨을 선택하지 마세요. 다음을 클릭합니다. 5. 확인을 클릭합니다. 새 사용자는 도메인 아래에 표시됩니다. RDS Custom for SQL Server를 사용하여 Microsoft Active Directory 작업 2037\n\n Amazon Relational Database Service 사용 설명서 3단계: 자체 관리형 또는 AWS Managed Microsoft AD에서 AD 사용자에게 제어 권한 위임 도메인의 AD 도메인 사용자에게 제어 권한을 위임하려면 1. Active Directory 사용자 및 컴퓨터 MMC 스냅인을 열고 도메인을 선택합니다. 2. 이전에 만든 OU를 마우스 오른쪽 버튼으로 클릭하고 제어 위임을 선택합니다. 3. 제어 위임 마법사에서 다음을 클릭합니다. 4. 사용자 또는 그룹 섹션에서 추가를 클릭합니다. 5. 사용자, 컴퓨터 또는 그룹 선택에서 생성한 AD 사용자를 입력하고 이름 확인을 클릭합니다. AD 사 용자 확인에 성공하면 확인을 클릭합니다. 6. 사용자 또는 그룹 섹션에서 AD 사용자가 추가되었는지 확인하고 다음을 클릭합니다. 7. 위임할 작업 섹션에서 위임할 사용자 지정 작업 생성을 선택하고 다음을 클릭합니다. 8. Active Directory 객체 유형 섹션에서: 폴더의 다음 객체만을 선택합니다. 컴퓨터 객체를 선택합니다. 이 폴더에서 선택한 객체 생성을 선택합니다. 이 폴더에서 선택한 객체 삭제를 선택하고 다음을 클릭합니다. 9. 권한 섹션에서: 일반을 선택한 상태로 유지합니다. DNS 호스트 이름에 대한 검증된 쓰기를 선택합니다. 서비스 보안 주체 이름에 대한 검증된 쓰기를 선택하고 다음을 클릭합니다. 10. 제어 위임 마법사를 완료하려면에서 설정을 확인한 다음 마침을 클릭합니다. 4단계: 보안 암호 생성 Active Directory에 포함하려는 RDS Custom for SQL Server DB 인스턴스가 포함된 동일한 AWS 계정 및 리전에 보안 암호를 만들어야 합니다. 2단계: AD 도메인 사용자 생성에서 생성된 AD 도메인 사용자 의 자격 증명을 저장합니다. RDS Custom for SQL Server를 사용하여 Microsoft Active Directory 작업 2038\n\n Amazon Relational Database Service Console 사용 설명서 • AWS Secrets Manager에서 새 암호 저장을 선택합니다. • 보안 암호 유형에서 다른 유형의 보안 암호를 선택합니다. • 키/값 쌍의 경우 2개의 키를 추가합니다. • 첫 번째 키 값에는 SELF_MANAGED_ACTIVE_DIRECTORY_USERNAME을 입력하고 AD 사용자 의 사용자 이름(도메인 접두사 제외)을 입력합니다. • 두 번째 키에 SELF_MANAGED_ACTIVE_DIRECTORY_PASSWORD를 입력하고 도메인에 AD 사 용자의 암호를 입력합니다. • 암호화 키에 RDS Custom for SQL Server 인스턴스를 생성하는 데 사용한 것과 동일한 AWS KMS 키를 입력합니다. • 보안 암호 이름에서 do-not-delete-rds-custom-으로 시작하는 보안 암호 이름을 선택하여 인스턴스 프로파일이 이 보안 암호에 액세스할 수 있도록 합니다. 보안 암호에 다른 이름을 선택 하려면 보안 암호 이름에 액세스하도록 RDSCustomInstanceProfile을 업데이트합니다. • (선택 사항) 설명에 보안 암호 이름에 대한 설명을 입력합니다. • 태그 Key=\"AWSRDSCustom\",Value=\"custom-sqlserver\" 추가 • 저장을 클릭한 후 다음을 클릭합니다. • 교체 설정 구성에서 기본값을 유지하고 다음을 선택합니다. • 보안 암호 설정을 검토하고 저장을 클릭합니다. • 새 보안 암호를 선택하고 보안 암호 ARN의 값을 복사합니다. 다음 단계에서 이를 사용하여 Active Directory를 설정합니다. CLI CLI에서 다음 명령을 실행하여 보안 암호를 생성합니다. # Linux based aws secretsmanager create-secret \\ --name do-not-delete-rds-custom-DomainUserCredentails \\ --description \"Active directory user credentials for managing RDS Custom\" \\ --secret-string \"{\\\"SELF_MANAGED_ACTIVE_DIRECTORY_USERNAME\\\":\\\"tester\\\", \\\"SELF_MANAGED_ACTIVE_DIRECTORY_PASSWORD\\\":\\\"xxxxxxxx\\\"}\" \\ --kms-key-id <RDSCustomKMSKey> \\ --tags Key=\"AWSRDSCustom\",Value=\"custom-sqlserver\" # Windows based RDS Custom for SQL Server를 사용하여 Microsoft Active Directory 작업 2039\n\n Amazon Relational Database Service 사용 설명서 aws secretsmanager create-secret ^ --name do-not-delete-rds-custom-DomainUserCredentails ^ --description \"Active directory user credentials for managing RDS Custom\" ^ --secret-string \"{\\\"SELF_MANAGED_ACTIVE_DIRECTORY_USERNAME\\\":\\\"tester\\\", \\\"SELF_MANAGED_ACTIVE_DIRECTORY_PASSWORD\\\":\\\"xxxxxxxx\\\"}\" ^ --kms-key-id <RDSCustomKMSKey> ^ --tags Key=\"AWSRDSCustom\",Value=\"custom-sqlserver\" 5단계: RDS Custom for SQL Server DB 인스턴스 생성 또는 수정 디렉터리에서 사용할 RDS Custom for SQL Server DB 인스턴스를 생성하거나 수정합니다. 콘솔, CLI 또는 RDS API를 사용하여 DB 인스턴스를 디렉터리에 연결할 수 있습니다. 이 작업을 다음 중 한 가지 방법으로 수행할 수 있습니다. • 콘솔, create-db-instance CLI 명령 또는 CreateDBInstance RDS API 작업을 사용하여 새 SQL Server DB 인스턴스를 생성합니다. 지침은 Amazon RDS DB 인스턴스 생성 섹션을 참조하세요. • 콘솔, modify-db-instance CLI 명령 또는 ModifyDBInstance RDS API 작업을 사용하여 기존 SQL Server DB 인스턴스를 수정합니다. 지침은 Amazon RDS DB 인스턴스 수정 섹션을 참조하세요. • 콘솔, restore-db-instance-from-db-snapshot CLI 명령 또는 RestoreDBInstanceFromDBSnapshot RDS API 작업을 사용하여 DB 스냅샷에서 SQL Server DB 인스턴스를 복원합니다. 지침은 DB 인스턴스 복원 섹션을 참조하세요. • 콘솔, restore-db-instance-to-point-in-time CLI 명령 또는 RestoreDBInstanceToPointInTime RDS API 작업을 사용하여 SQL Server DB 인스턴스를 특정 시점으로 복구합니다. 지침은 Amazon RDS에서 DB 인스턴스를 지정된 시간으로 복원 섹션을 참조하세요. Note RDS Custom for SQL Server 인스턴스가 이미 AD에 수동으로 조인된 경우 네트워크 구성 포 트 규칙, 네트워크 검증의 설정을 확인하고 1~4단계를 완료합니다. 도메인 조인 보안 인증 정 보 및 구성이 RDS Custom에 등록되어 CNAME를 모니터링, 등록 및 복구 작업을 수행할 수 있 RDS Custom for SQL Server를 사용하여 Microsoft Active\n\nCLI 명령 또는 CreateDBInstance RDS API 작업을 사용하여 새 SQL Server DB 인스턴스를 생성합니다. 지침은 Amazon RDS DB 인스턴스 생성 섹션을 참조하세요. • 콘솔, modify-db-instance CLI 명령 또는 ModifyDBInstance RDS API 작업을 사용하여 기존 SQL Server DB 인스턴스를 수정합니다. 지침은 Amazon RDS DB 인스턴스 수정 섹션을 참조하세요. • 콘솔, restore-db-instance-from-db-snapshot CLI 명령 또는 RestoreDBInstanceFromDBSnapshot RDS API 작업을 사용하여 DB 스냅샷에서 SQL Server DB 인스턴스를 복원합니다. 지침은 DB 인스턴스 복원 섹션을 참조하세요. • 콘솔, restore-db-instance-to-point-in-time CLI 명령 또는 RestoreDBInstanceToPointInTime RDS API 작업을 사용하여 SQL Server DB 인스턴스를 특정 시점으로 복구합니다. 지침은 Amazon RDS에서 DB 인스턴스를 지정된 시간으로 복원 섹션을 참조하세요. Note RDS Custom for SQL Server 인스턴스가 이미 AD에 수동으로 조인된 경우 네트워크 구성 포 트 규칙, 네트워크 검증의 설정을 확인하고 1~4단계를 완료합니다. 도메인 조인 보안 인증 정 보 및 구성이 RDS Custom에 등록되어 CNAME를 모니터링, 등록 및 복구 작업을 수행할 수 있 RDS Custom for SQL Server를 사용하여 Microsoft Active Directory 작업 2040\n\n Amazon Relational Database Service 사용 설명서 도록 --domain-fqdn, --domain-ou 및 --domain-auth-secret-arn을 AD로 업데이트 합니다. AWS CLI를 사용하는 경우 생성한 도메인 디렉터리를 DB 인스턴스에서 사용하려면 다음과 같은 파라 미터가 필요합니다. • --domain-fqdn 파라미터에는 자체 관리형 AD의 정규화된 도메인 이름을 사용합니다. • --domain-ou 파라미터에는 자체 관리형 AD에서 만든 OU를 사용합니다. • --domain-auth-secret-arn 파라미터에는 생성한 보안 암호 ARN의 값을 사용합니다. Important 자체 관리형 AD 도메인에 조인하거나 자체 관리형 AD 도메인 또는 AWS Managed Microsoft AD에서 제거하도록 DB 인스턴스를 수정한 경우 변경 사항이 적용되려면 DB 인스턴스를 재부 팅해야 합니다. 변경 사항을 즉시 적용하거나 다음 유지 관리 기간까지 기다릴 수 있습니다. 즉 시 적용 옵션을 선택하면 단일 AZ DB 인스턴스에 가동 중단이 발생합니다. 다중 AZ DB 클러스 터는 재부팅을 완료하기 전에 장애 조치를 수행합니다. 자세한 내용은 Amazon RDS DB 인스 턴스 수정 섹션을 참조하세요. 다음 CLI 명령은 새 RDS Custom for SQL Server DB 인스턴스를 만들어 자체 관리형 또는 AWS Managed Microsoft AD 도메인에 조인합니다. 대상 LinuxmacOS, 또는Unix: aws rds create-db-instance \\ --engine custom-sqlserver-se \\ --engine-version 15.00.4312.2.v1 \\ --db-instance-identifier my-custom-instance \\ --db-instance-class db.m5.large \\ --allocated-storage 100 --storage-type io1 --iops 1000 \\ --master-username my-master-username \\ --master-user-password my-master-password \\ --kms-key-id my-RDSCustom-key-id \\ --custom-iam-instance-profile AWSRDSCustomInstanceProfileForRdsCustomInstance \\ --domain-fqdn \"corp.example.com\" \\ --domain-ou \"OU=RDSCustomOU,DC=corp,DC=example,DC=com\" \\ RDS Custom for SQL Server를 사용하여 Microsoft Active Directory 작업 2041\n\n Amazon Relational Database Service 사용 설명서 --domain-auth-secret-arn \"arn:aws:secretsmanager:region:account-number:secret:do-not- delete-rds-custom-my-AD-test-secret-123456\" \\ --db-subnet-group-name my-DB-subnet-grp \\ --vpc-security-group-ids my-securitygroup-id \\ --no-publicly-accessible \\ --backup-retention-period 3 \\ --port 8200 \\ --region us-west-2 \\ --no-multi-az Windows의 경우: aws rds create-db-instance ^ --engine custom-sqlserver-se ^ --engine-version 15.00.4312.2.v1 ^ --db-instance-identifier my-custom-instance ^ --db-instance-class db.m5.large ^ --allocated-storage 100 --storage-type io1 --iops 1000 ^ --master-usernamemy-master-username ^ --master-user-password my-master-password ^ --kms-key-id my-RDSCustom-key-id ^ --custom-iam-instance-profile AWSRDSCustomInstanceProfileForRdsCustomInstance ^ --domain-fqdn \"corp.example.com\" ^ --domain-ou \"OU=RDSCustomOU,DC=corp,DC=example,DC=com\" ^ --domain-auth-secret-arn \"arn:aws:secretsmanager:region:account-number:secret:do-not- delete-rds-custom-my-AD-test-secret-123456\" ^ --db-subnet-group-name my-DB-subnet-grp ^ --vpc-security-group-ids my-securitygroup-id ^ --no-publicly-accessible ^ --backup-retention-period 3 ^ --port 8200 ^ --region us-west-2 ^ --no-multi-az Important AWS Managed Microsoft AD에 대한 NetBIOS가 corpexample인 경 우 OU 자체로 표시됩니다. 이전에 생성된 새 OU는 중첩 OU로 표 시됩니다. AWS Managed Microsoft AD의 경우 --domain-ou을 RDS Custom for SQL Server를 사용하여 Microsoft Active Directory 작업 2042\n\n Amazon Relational Database Service 사용 설명서 \"OU=RDSCustomOU,OU=corpexample,DC=corp,DC=example,DC=com\"으로 설정합니 다. 다음 명령은 Active Directory 도메인을 사용하도록 기존 RDS Custom for SQL Server DB 인스턴스를 수정합니다. 대상 LinuxmacOS, 또는Unix: aws rds modify-db-instance \\ --db-instance-identifier my-custom-instance \\ --domain-fqdn \"corp.example.com\" \\ --domain-ou \"OU=RDSCustomOU,DC=corp,DC=example,DC=com\" \\ --domain-auth-secret-arn \"arn:aws:secretsmanager:region:account-number:secret:do- not-delete-rds-custom-my-AD-test-secret-123456\" \\ Windows의 경우: aws rds modify-db-instance ^ --db-instance-identifier my-custom-instance ^ --domain-fqdn \"corp.example.com\" ^ --domain-ou \"OU=RDSCustomOU,DC=corp,DC=example,DC=com\" ^ --domain-auth-secret-arn \"arn:aws:secretsmanager:region:account-number:secret:do- not-delete-rds-custom-my-AD-test-secret-123456\" ^ 다음 CLI 명령은 Active Directory 도메인에서 RDS Custom for SQL Server DB 인스턴스를 제거합니 다. 대상 LinuxmacOS, 또는Unix: aws rds modify-db-instance \\ --db-instance-identifier my-custom-instance \\ --disable-domain Windows의 경우: aws rds modify-db-instance ^ --db-instance-identifier my-custom-instance ^ --disable-domain RDS Custom for SQL Server를 사용하여 Microsoft Active Directory 작업 2043\n\n Amazon Relational Database Service 사용 설명서 콘솔을 사용하여 인스턴스를 생성하거나 수정할 때 Microsoft SQL Server Windows 인증 활성화를 클 릭하여 다음 옵션을 확인합니다. 도메인 FQDN이 도메인 컨트롤러 IP 주소로 확인되고 있는지 확인하는 것은 사용자의 책임입니다. 도 메인 컨트롤러 IP가 확인되지 않으면 도메인 조인 작업은 실패하지만 RDS Custom for SQL Server 인 스턴스 만들기에 성공합니다. 문제 해결 정보는 Active Directory 문제 해결를 참조하세요. 6단계: Windows 인증 SQL Server 로그인 생성 다른 DB 인스턴스의 경우와 같은 방법으로 Amazon RDS 마스터 사용자 보안 인증 정보를 사용하여 SQL Server DB 인스턴스에 연결합니다. DB 인스턴스는 AD 도메인에 조인되므로 SQL Server 로그인 및 사용자를 프로비저닝할 수 있습니다. 이 작업은 AD 도메인의 AD 사용자 및 그룹 유틸리티에서 수행 합니다. 데이터베이스 권한은 이러한 Windows 로그인에 부여되거나 취소되는 표준 SQL Server 권한 을 통해 관리됩니다. AD 사용자가 SQL Server로 인증하려면 AD 사용자 또는 사용자가 속한 Active Directory 그룹에 대한 SQL Server Windows 로그인이 있어야 합니다. 세분화된 액세스 제어는 이러한 SQL Server 로그인에 대한 권한을 부여하거나 취소하여 처리합니다. SQL Server 로그인이 없거나 이러한 로그인이 있는 AD 그룹에 속하지 않은 AD 사용자는 SQL Server DB 인스턴스에 액세스할 수 없습니다. AD SQL Server 로그인을 생성하려면 ALTER ANY LOGIN 권한이 필요합니다. 이 권한으로 로그인을 생성하지 않은 경우 SQL Server 인증을 사용하여 DB 인스턴스의 마스터 사용자로 연결하고 마스터 사 용자의 맥락에서 AD SQL Server 로그인을 생성합니다. RDS Custom for SQL Server를 사용하여 Microsoft Active Directory 작업 2044\n\n Amazon Relational Database Service 사용 설명서 다음과 같은 데이터 정의 언어(DDL) 명령을 실행하여 AD 사용자 또는 그룹에 대한 SQL Server 로그인 을 생성할 수 있습니다. USE [master] GO CREATE LOGIN [mydomain\\myuser] FROM WINDOWS WITH DEFAULT_DATABASE = [master], DEFAULT_LANGUAGE = [us_english]; GO 도메인의 사용자(사람 및 애플리케이션)는 이제 Windows 인증을 사용하여 도메인이 조인된 클라이언 트 컴퓨터의 RDS Custom for SQL Server 인스턴스에 연결할 수 있습니다. 7단계: Kerberos 또는 NTLM 인증 사용\n\n있어야 합니다. 세분화된 액세스 제어는 이러한 SQL Server 로그인에 대한 권한을 부여하거나 취소하여 처리합니다. SQL Server 로그인이 없거나 이러한 로그인이 있는 AD 그룹에 속하지 않은 AD 사용자는 SQL Server DB 인스턴스에 액세스할 수 없습니다. AD SQL Server 로그인을 생성하려면 ALTER ANY LOGIN 권한이 필요합니다. 이 권한으로 로그인을 생성하지 않은 경우 SQL Server 인증을 사용하여 DB 인스턴스의 마스터 사용자로 연결하고 마스터 사 용자의 맥락에서 AD SQL Server 로그인을 생성합니다. RDS Custom for SQL Server를 사용하여 Microsoft Active Directory 작업 2044\n\n Amazon Relational Database Service 사용 설명서 다음과 같은 데이터 정의 언어(DDL) 명령을 실행하여 AD 사용자 또는 그룹에 대한 SQL Server 로그인 을 생성할 수 있습니다. USE [master] GO CREATE LOGIN [mydomain\\myuser] FROM WINDOWS WITH DEFAULT_DATABASE = [master], DEFAULT_LANGUAGE = [us_english]; GO 도메인의 사용자(사람 및 애플리케이션)는 이제 Windows 인증을 사용하여 도메인이 조인된 클라이언 트 컴퓨터의 RDS Custom for SQL Server 인스턴스에 연결할 수 있습니다. 7단계: Kerberos 또는 NTLM 인증 사용 RDS 엔드포인트를 사용한 NTLM 인증 각 Amazon RDS DB 인스턴스에는 엔드포인트가 있으며, 각 엔드포인트에는 DB 인스턴스의 DNS 이 름과 포트 번호가 있습니다. SQL 클라이언트 애플리케이션을 사용해 DB 인스턴스에 연결하려면 DB 인스턴스에 연결할 수 있는 DNS 이름과 포트 번호가 필요합니다. NTLM 인증을 사용하여 인증하려면 RDS 엔드포인트에 연결해야 합니다. 계획된 데이터베이스 유지 관리 또는 예기치 않은 서비스 중단이 발생할 경우 Amazon RDS가 최신 보 조 데이터베이스로 자동으로 장애 조치를 수행하므로 수동 개입 없이 작업을 빠르게 재개할 수 있습니 다. 기본 인스턴스 및 보조 인스턴스는 동일한 엔드포인트를 사용합니다. 이 엔드포인트의 물리적 네트 워크 주소는 장애 조치 프로세스의 일환으로 보조로 전환됩니다. 장애 조치가 발생하는 경우 애플리케 이션을 다시 구성할 필요가 없습니다. Kerberos 인증 RDS Custom for SQL Server에 대한 Kerberos 기반 인증을 수행하려면 특정 서비스 보안 주체 이름 (SPN)에 연결해야 합니다. 그러나 장애 조치 이벤트 후 애플리케이션이 새 SPN을 인식하지 못할 수 있 습니다. 이를 해결하기 위해 RDS Custom for SQL Server는 Kerberos 기반 엔드포인트를 제공합니다. Kerberos 기반 엔드포인트는 특정 형식을 따릅니다. RDS 엔드포인트가 rds-instance- name.account-region-hash.aws-region.rds.amazonaws.com인 경우 해당 Kerberos 기 반 엔드포인트는 rds-instance-name.account-region-hash.aws-region.awsrds.fully qualified domain name (FQDN)입니다. 예를 들어 RDS 엔드포인트가 ad-test.cocv6zwtircu.us-east-1.rds.amazonaws.com이 고 도메인 이름이 corp-ad.company.com인 경우 Kerberos 기반 엔드포인트는 ad- test.cocv6zwtircu.us-east-1.awsrds.corp-ad.company.com입니다. RDS Custom for SQL Server를 사용하여 Microsoft Active Directory 작업 2045\n\n Amazon Relational Database Service 사용 설명서 이 Kerberos 기반 엔드포인트는 기본 SQL Server 인스턴스의 새 SPN을 가리키도록 엔드포인트가 자 동으로 업데이트되므로 장애 조치 이벤트 후에도 Kerberos를 사용하여 SQL Server 인스턴스로 인증 하는 데 사용할 수 있습니다. CNAME 찾기 CNAME를 찾으려면 도메인 컨트롤러에 연결하고 DNS Manager를 엽니다. 정방향 조회 영역 및 FQDN으로 이동합니다. awsrds, aws-region, 계정 및 리전별 해시를 탐색합니다. RDS Custom EC2 인스턴스를 연결하고 CNAME를 사용하여 로컬에서 데이터베이스에 연결하려고 하 면 연결에서 Kerberos 대신 NTLM 인증을 사용합니다. 원격 클라이언트에서 CNAME를 연결한 후 NTLM 연결이 반환되면 필요한 포트가 허용 목록에 있는지 확인합니다. 연결에서 Kerberos를 사용 중인지 확인하려면 다음 쿼리를 실행합니다. SELECT net_transport, auth_scheme FROM sys.dm_exec_connections WHERE session_id = @@SSPID; 도메인에서 DB 인스턴스 관리 콘솔, AWS CLI 또는 Amazon RDS API를 사용하여 DB 인스턴스 및 DB 인스턴스와 도메인과의 관계 를 관리할 수 있습니다. 예를 들어, DB 인스턴스를 도메인 내로, 도메인 외부로 또는 도메인 간에 이동 할 수 있습니다. 예를 들어 Amazon RDS API를 사용하여 다음을 수행할 수 있습니다. • 실패한 멤버십에 대한 도메인 조인을 다시 시도하려면 ModifyDBInstance API 작업을 사용하고 현재 멤버십의 디렉터리 ID를 지정합니다. • 멤버십에 대한 IAM 역할 이름을 업데이트하려면 ModifyDBInstance API 작업을 사용하고 현재 멤버십의 디렉터리 ID 및 새 IAM 역할을 지정합니다. • 도메인에서 DB 인스턴스를 제거하려면 ModifyDBInstance API 작업을 사용하고 none을 도메인 파라미터로 지정합니다. • 한 도메인에서 다른 도메인으로 DB 인스턴스를 이동하려면 ModifyDBInstance API 작업을 사용 하여 새 도메인의 도메인 식별자를 도메인 파라미터로 지정합니다. RDS Custom for SQL Server를 사용하여 Microsoft Active Directory 작업 2046\n\n Amazon Relational Database Service 사용 설명서 • 각 DB 인스턴스에 대한 멤버십을 나열하려면 DescribeDBInstances API 작업을 사용합니다. RDS Custom for SQL Server DB 인스턴스 복원 및 Active Directory 도메인에 추가 DB 스냅샷을 복원하거나 SQL Server DB 인스턴스에 대한 특정 시점 복구(PITR)를 수행한 후 Active Directory 도메인에 추가할 수 있습니다. DB 인스턴스가 복원된 후 5단계: RDS Custom for SQL Server DB 인스턴스 생성 또는 수정에 설명된 프로세스를 사용하여 DB 인스턴스를 AD 도메인에 추가 하도록 인스턴스를 수정합니다. 도메인 멤버십 이해 DB 인스턴스를 생성하거나 수정한 경우 해당 인스턴스는 도메인의 구성원이 됩니다. AWS 콘솔은 DB 인스턴스에 대한 도메인 멤버십의 상태를 나타냅니다. DB 인스턴스의 상태는 다음 중 한 가지가 될 수 있습니다. • joined – 인스턴스가 도메인의 구성원입니다. • joining – 인스턴스가 도메인 구성원이 되기 위한 과정을 진행하고 있습니다. • pending-join – 인스턴스 멤버십이 보류 중입니다. • pending-maintenance-join - AWS에서 다음 예약된 유지 관리 기간 동안 인스턴스를 도메인의 멤버 로 만들려고 시도합니다. • pending-removal – 도메인에서 인스턴스 제거 작업이 보류 중입니다. • pending-maintenance-removal - AWS에서 다음 예약된 유지 관리 기간 동안 도메인에서 인스턴스를 제거하려고 시도합니다. • failed – 구성 문제가 발생하여 인스턴스가 도메인에 조인되지 않았습니다. 인스턴스 수정 명령을 다 시 실행하기 전에 구성을 확인하고 수정합니다. • removing – 인스턴스를 도메인에서 제거하고 있습니다. 네트워크 연결 문제 또는 잘못된 IAM 역할로 인해 도메인 구성원 되기 요청이 실패할 수 있습니다. 예 를 들어, DB 인스턴스를 생성하거나 기존 인스턴스를 수정하여 DB 인스턴스가 도메인의 멤버가 되려 는 시도를 못하게 할 수 있습니다. 이 경우 명령을 다시 실행하여 DB 인스턴스를 생성 또는 수정하거나 새로 생성된 인스턴스를 수정하여 도메인에 조인할 수 있습니다. Active Directory 문제 해결 다음은 AD를 설정하거나 수정할 때 발생할 수 있는 문제입니다. RDS Custom for SQL Server를 사용하여 Microsoft Active Directory 작업 2047\n\n Amazon Relational Database Service 사용 설명서 오류 코드 오류 2/0x2 설명 일반적인 원인 문제 해결 제안 시스템이 지정된 파 —domain-ou 파라미터 로 지정된 조직 단위(OU) —domain-ou 파라미터 를 검토합니다. 도메인 서 일을 찾을 의"}, {"ref": "/docs/aws-cli_pdf_cli-chap-welcome.pdf", "chunk_id": "aws/aws-cli_pdf_cli-chap-welcome_pdf#chunk806", "doc_id": "aws/aws-cli_pdf_cli-chap-welcome_pdf", "page": 5047, "anchor": "\"6.0\", \"Authentication\": { \"Type\": \"no-password\" }, \"ARN\": \"arn:aws:memorydb:us-east-1:491658xxxxxx:user/default\" }, { \"Name\": \"my-user\", \"Status\": \"active\", \"AccessString\": \"off ~objects:* ~items:* ~public:* resetchannels -@all\", \"ACLNames\": [], \"MinimumEngineVersion\": \"6.2\", \"Authentication\": { \"Type\": \"password\", \"PasswordCount\": 2 }, \"ARN\": \"arn:aws:memorydb:us-east-1:491658xxxxxx:user/my-user\" } ] } 자세한 내용은 MemoryDB 사용자 안내서의 액세스 제어 목록을 사용하여 사용자 인증을 참조하세 요. • API 세부 정보는 AWS CLI 명령 참조의 DescribeUsers를 참조하세요. failover-shard 다음 코드 예시에서는 failover-shard의 사용 방법을 보여줍니다. AWS CLI 샤드 장애 조치 다음 failover-shard는 샤드를 장애 조치합니다. aws memorydb failover-shard \\ --cluster-name my-cluster --shard-name 0001 출력: { MemoryDB 5024\n\n AWS Command Line Interface 버전 2 사용 설명서 \"Cluster\": { \"Name\": \"my-cluster\", \"Status\": \"available\", \"NumberOfShards\": 2, \"ClusterEndpoint\": { \"Address\": \"clustercfg.my-cluster.xxxxxx.memorydb.us- east-1.amazonaws.com\", \"Port\": 6379 }, \"NodeType\": \"db.r6g.large\", \"EngineVersion\": \"6.2\", \"EnginePatchVersion\": \"6.2.6\", \"ParameterGroupName\": \"default.memorydb-redis6\", \"ParameterGroupStatus\": \"in-sync\", \"SecurityGroups\": [ { \"SecurityGroupId\": \"sg-0a143xxxx45c9fae\", \"Status\": \"active\" } ], \"SubnetGroupName\": \"my-sg\", \"TLSEnabled\": true, \"ARN\": \"arn:aws:memorydb:us-east-1:491658xxxxxx:cluster/my-cluster\", \"SnapshotRetentionLimit\": 0, \"MaintenanceWindow\": \"wed:03:00-wed:04:00\", \"SnapshotWindow\": \"04:30-05:30\", \"AutoMinorVersionUpgrade\": true } } 자세한 내용은 MemoryDB 사용자 안내서의 MultiAZ로 가동 중지 시간 최소화를 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 FailoverShard를 참조하세요. list-allowed-node-type-updates 다음 코드 예시에서는 list-allowed-node-type-updates의 사용 방법을 보여줍니다. AWS CLI 허용된 노드 유형 업데이트의 목록 반환 다음 list-allowed-node-type-updates는 사용 가능한 노드 유형 업데이트 목록을 반환합니다. MemoryDB 5025\n\n AWS Command Line Interface 버전 2 사용 설명서 aws memorydb list-allowed-node-type-updates 출력: { \"Cluster\": { \"Name\": \"my-cluster\", \"Status\": \"available\", \"NumberOfShards\": 2, \"ClusterEndpoint\": { \"Address\": \"clustercfg.my-cluster.xxxxxx.memorydb.us- east-1.amazonaws.com\", \"Port\": 6379 }, \"NodeType\": \"db.r6g.large\", \"EngineVersion\": \"6.2\", \"EnginePatchVersion\": \"6.2.6\", \"ParameterGroupName\": \"default.memorydb-redis6\", \"ParameterGroupStatus\": \"in-sync\", \"SecurityGroups\": [ { \"SecurityGroupId\": \"sg-0a143xxxx45c9fae\", \"Status\": \"active\" } ], \"SubnetGroupName\": \"my-sg\", \"TLSEnabled\": true, \"ARN\": \"arn:aws:memorydb:us-east-1:491658xxxxxx:cluster/my-cluster\", \"SnapshotRetentionLimit\": 0, \"MaintenanceWindow\": \"wed:03:00-wed:04:00\", \"SnapshotWindow\": \"04:30-05:30\", \"AutoMinorVersionUpgrade\": true } } 자세한 내용은 MemoryDB 사용자 안내서의 스케일링을 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 ListAllowedNodeTypeUpdates를 참조하세요. list-tags 다음 코드 예시에서는 list-tags의 사용 방법을 보여줍니다. MemoryDB 5026\n\n AWS Command Line Interface AWS CLI 태그 목록 반환 다음 list-tags는 태그 목록을 반환합니다. 버전 2 사용 설명서 aws memorydb list-tags \\ --resource-arn arn:aws:memorydb:us-east-1:491658xxxxxx:cluster/my-cluster 출력: { \"TagList\": [ { \"Key\": \"mytag\", \"Value\": \"myvalue\" } ] } 자세한 내용은 MemoryDB 사용자 안내서의 리소스 태그 지정을 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 ListTags를 참조하세요. reset-parameter-group 다음 코드 예시에서는 reset-parameter-group의 사용 방법을 보여줍니다. AWS CLI 파라미터 그룹 재설정 다음 reset-parameter-group은 파라미터 그룹을 재설정합니다. aws memorydb reset-parameter-group \\ --parameter-group-name my-parameter-group \\ --all-parameters 출력: { MemoryDB 5027\n\n AWS Command Line Interface 버전 2 사용 설명서 \"ParameterGroup\": { \"Name\": \"my-parameter-group\", \"Family\": \"memorydb_redis6\", \"Description\": \"my parameter group\", \"ARN\": \"arn:aws:memorydb:us-east-1:491658xxxxxx:parametergroup/my-parameter- group\" } } 자세한 내용은 MemoryDB 사용자 안내서의 파라미터 그룹을 사용하여 엔진 파라미터 구성을 참조 하세요. • API 세부 정보는 AWS CLI 명령 참조의 ResetParameterGroup을 참조하세요. tag-resource 다음 코드 예시에서는 tag-resource의 사용 방법을 보여줍니다. AWS CLI 리소스에 태그 지정 다음 tag-resource는 리소스에 태그를 추가합니다. aws memorydb tag-resource \\ --resource-arn arn:aws:memorydb:us-east-1:491658xxxxxx:cluster/my-cluster \\ --tags Key=\"mykey\",Value=\"myvalue\" 출력: { \"TagList\": [ { \"Key\": \"mytag\", \"Value\": \"myvalue\" }, { \"Key\": \"mykey\", \"Value\": \"myvalue\" } ] } MemoryDB 5028\n\n AWS Command Line Interface 버전 2 사용 설명서 자세한 내용은 MemoryDB 사용자 안내서의 리소스 태그 지정을 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 TagResource를 참조하세요. untag-resource 다음 코드 예시에서는 untag-resource의 사용 방법을 보여줍니다. AWS CLI ACL 업데이트 다음 update-acl은 사용자를 추가하여 ACL을 업데이트합니다. aws memorydb untag-resource \\ --resource-arn arn:aws:memorydb:us-east-1:491658xxxxx:cluster/my-cluster \\ --tag-keys mykey 출력: { \"TagList\": [ { \"Key\": \"mytag\", \"Value\": \"myvalue\" } ] } 자세한 내용은 MemoryDB 사용자 안내서의 리소스 태그 지정을 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 UntagResource를 참조하세요. update-cluster 다음 코드 예시에서는 update-cluster의 사용 방법을 보여줍니다. AWS CLI 클러스터 업데이트 다음 update-cluster는 클러스터의 파라미터 그룹을 my-parameter-group으로 업데이트합니다. MemoryDB 5029\n\n AWS Command Line Interface 버전 2 사용 설명서 aws memorydb update-cluster \\ --cluster-name my-cluster \\ --parameter-group-name my-parameter-group 출력: { \"Cluster\": { \"Name\": \"my-cluster\", \"Status\": \"available\", \"NumberOfShards\": 2, \"AvailabilityMode\": \"MultiAZ\", \"ClusterEndpoint\": { \"Address\": \"clustercfg.my-cluster.llru6f.memorydb.us- east-1.amazonaws.com\", \"Port\": 6379 }, \"NodeType\": \"db.r6g.large\", \"EngineVersion\": \"6.2\", \"EnginePatchVersion\": \"6.2.6\", \"ParameterGroupName\": \"my-parameter-group\", \"ParameterGroupStatus\": \"in-sync\", \"SecurityGroups\": [ { \"SecurityGroupId\": \"sg-0a143xxxxxc9fae\", \"Status\": \"active\" } ], \"SubnetGroupName\": \"pat-sg\", \"TLSEnabled\": true, \"ARN\": \"arn:aws:memorydb:us-east-1:491658xxxxxx:cluster/my-cluster\", \"SnapshotRetentionLimit\": 0, \"MaintenanceWindow\": \"wed:03:00-wed:04:00\", \"SnapshotWindow\": \"04:30-05:30\", \"ACLName\": \"my-acl\", \"AutoMinorVersionUpgrade\": true } } 자세한 내용은 MemoryDB 사용자 안내서의 클러스터 수정을 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 UpdateCluster를 참조하세요. MemoryDB 5030\n\n AWS Command Line Interface update-parameter-group 버전 2 사용 설명서 다음 코드 예시에서는 update-parameter-group의 사용 방법을 보여줍니다. AWS CLI 파라미터 그룹 업데이트 다음 update-parameter-group은 파라미터 그룹을 업데이트합니다. aws memorydb update-parameter-group \\ --parameter-group-name my-parameter-group \\ --parameter-name-values \"ParameterName=activedefrag, ParameterValue=no\" 출력: { \"ParameterGroup\": { \"Name\": \"my-parameter-group\", \"Family\": \"memorydb_redis6\", \"Description\": \"my parameter group\", \"ARN\": \"arn:aws:memorydb:us-east-1:49165xxxxxx:parametergroup/my-parameter- group\" } } 자세한 내용은 MemoryDB 사용자 안내서의 파라미터 그룹 수정을 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 UpdateParameterGroup을 참조하세요. update-subnet-group 다음 코드 예시에서는 update-subnet-group의 사용 방법을 보여줍니다. AWS CLI 서브넷 그룹 업데이트 다음 update-subnet-group은 서브넷 그룹의 서브넷 ID를 업데이트합니다. aws memorydb update-subnet-group \\ --subnet-group-name my-sg \\ --subnet-ids subnet-01f29d458f3xxxxx MemoryDB 5031\n\n AWS Command Line Interface 버전 2 사용 설명서 출력: { \"SubnetGroup\": { \"Name\": \"my-sg-1\", \"Description\": \"my-sg\", \"VpcId\": \"vpc-09d2cfc01xxxxxxx\", \"Subnets\": [ { \"Identifier\": \"subnet-01f29d458fxxxxxx\", \"AvailabilityZone\": { \"Name\": \"us-east-1a\" } } ], \"ARN\": \"arn:aws:memorydb:us-east-1:491658xxxxxx:subnetgroup/my-sg\" } } 자세한 내용은 MemoryDB 사용자 안내서의 서브넷 및 서브넷 그룹을 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 UpdateSubnetGroup을 참조하세요. update-user 다음 코드 예시에서는 update-user의 사용 방법을 보여줍니다. AWS CLI 사용자 업데이트 다음 update-user는 사용자의 액세스 문자열을 수정합니다. aws memorydb update-user \\ --user-name my-user \\ --access-string \"off ~objects:* ~items:* ~public:* resetchannels -@all\" 출력: { \"User\": { \"Name\": \"my-user\", \"Status\": \"modifying\", MemoryDB 5032\n\n AWS Command Line Interface 버전 2 사용 설명서 \"AccessString\": \"off ~objects:* ~items:* ~public:* resetchannels -@all\", \"ACLNames\": [\n\nUpdateParameterGroup을 참조하세요. update-subnet-group 다음 코드 예시에서는 update-subnet-group의 사용 방법을 보여줍니다. AWS CLI 서브넷 그룹 업데이트 다음 update-subnet-group은 서브넷 그룹의 서브넷 ID를 업데이트합니다. aws memorydb update-subnet-group \\ --subnet-group-name my-sg \\ --subnet-ids subnet-01f29d458f3xxxxx MemoryDB 5031\n\n AWS Command Line Interface 버전 2 사용 설명서 출력: { \"SubnetGroup\": { \"Name\": \"my-sg-1\", \"Description\": \"my-sg\", \"VpcId\": \"vpc-09d2cfc01xxxxxxx\", \"Subnets\": [ { \"Identifier\": \"subnet-01f29d458fxxxxxx\", \"AvailabilityZone\": { \"Name\": \"us-east-1a\" } } ], \"ARN\": \"arn:aws:memorydb:us-east-1:491658xxxxxx:subnetgroup/my-sg\" } } 자세한 내용은 MemoryDB 사용자 안내서의 서브넷 및 서브넷 그룹을 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 UpdateSubnetGroup을 참조하세요. update-user 다음 코드 예시에서는 update-user의 사용 방법을 보여줍니다. AWS CLI 사용자 업데이트 다음 update-user는 사용자의 액세스 문자열을 수정합니다. aws memorydb update-user \\ --user-name my-user \\ --access-string \"off ~objects:* ~items:* ~public:* resetchannels -@all\" 출력: { \"User\": { \"Name\": \"my-user\", \"Status\": \"modifying\", MemoryDB 5032\n\n AWS Command Line Interface 버전 2 사용 설명서 \"AccessString\": \"off ~objects:* ~items:* ~public:* resetchannels -@all\", \"ACLNames\": [ \"myt-acl\" ], \"MinimumEngineVersion\": \"6.2\", \"Authentication\": { \"Type\": \"password\", \"PasswordCount\": 2 }, \"ARN\": \"arn:aws:memorydb:us-east-1:491658xxxxxx:user/my-user\" } } 자세한 내용은 MemoryDB 사용자 안내서의 액세스 제어 목록을 사용하여 사용자 인증을 참조하세 요. • API 세부 정보는 AWS CLI 명령 참조의 UpdateUser를 참조하세요. AWS CLI를 사용한 Amazon MSK 예시 다음 코드 예시는 Amazon MSK와 함께 AWS Command Line Interface를 사용하여 작업을 수행하고 일반적인 시나리오를 구현하는 방법을 보여줍니다. 작업은 대규모 프로그램에서 발췌한 코드이며 컨텍스트에 맞춰 실행해야 합니다. 작업은 관련 시나리 오의 컨텍스트에 따라 표시되며, 개별 서비스 함수를 직접적으로 호출하는 방법을 보여줍니다. 각 예시에는 전체 소스 코드에 대한 링크가 포함되어 있으며, 여기에서 컨텍스트에 맞춰 코드를 설정하 고 실행하는 방법에 대한 지침을 찾을 수 있습니다. 주제 • 작업 작업 create-cluster 다음 코드 예시에서는 create-cluster의 사용 방법을 보여줍니다. AWS CLI Amazon MSK 클러스터 생성 Amazon MSK 5033\n\n AWS Command Line Interface 버전 2 사용 설명서 다음 create-cluster 예시에서는 3개의 브로커 노드로 MessagingCluster라는 MSK 클러스 터를 생성합니다. brokernodegroupinfo.json이라는 JSON 파일은 Amazon MSK가 브로커 노 드를 배포할 세 개의 서브넷을 지정합니다. 이 예시에서는 모니터링 수준을 지정하지 않으므로 클 러스터가 DEFAULT 수준을 가져옵니다. aws kafka create-cluster \\ --cluster-name \"MessagingCluster\" \\ --broker-node-group-info file://brokernodegroupinfo.json \\ --kafka-version \"2.2.1\" \\ --number-of-broker-nodes 3 brokernodegroupinfo.json의 콘텐츠: { \"InstanceType\": \"kafka.m5.xlarge\", \"BrokerAZDistribution\": \"DEFAULT\", \"ClientSubnets\": [ \"subnet-0123456789111abcd\", \"subnet-0123456789222abcd\", \"subnet-0123456789333abcd\" ] } 출력: { \"ClusterArn\": \"arn:aws:kafka:us-west-2:123456789012:cluster/MessagingCluster/ a1b2c3d4-5678-90ab-cdef-11111EXAMPLE-2\", \"ClusterName\": \"MessagingCluster\", \"State\": \"CREATING\" } 자세한 내용은 Amazon Managed Streaming for Apache Kafka의 Amazon MSK 클러스터 생성을 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 CreateCluster를 참조하세요. create-configuration 다음 코드 예시에서는 create-configuration의 사용 방법을 보여줍니다. Amazon MSK 5034\n\n AWS Command Line Interface AWS CLI 사용자 지정 Amazon MSK 구성 생성 버전 2 사용 설명서 다음 create-configuration 예시에서는 입력 파일에 지정된 서버 속성을 사용하여 사용자 지 정 MSK 구성을 생성합니다. aws kafka create-configuration \\ --name \"CustomConfiguration\" \\ --description \"Topic autocreation enabled; Apache ZooKeeper timeout 2000 ms; Log rolling 604800000 ms.\" \\ --kafka-versions \"2.2.1\" \\ --server-properties file://configuration.txt configuration.txt의 콘텐츠: auto.create.topics.enable = true zookeeper.connection.timeout.ms = 2000 log.roll.ms = 604800000 이 명령은 출력을 생성하지 않습니다. 출력: { \"Arn\": \"arn:aws:kafka:us-west-2:123456789012:configuration/CustomConfiguration/ a1b2c3d4-5678-90ab-cdef-11111EXAMPLE-2\", \"CreationTime\": \"2019-10-09T15:26:05.548Z\", \"LatestRevision\": { \"CreationTime\": \"2019-10-09T15:26:05.548Z\", \"Description\": \"Topic autocreation enabled; Apache ZooKeeper timeout 2000 ms; Log rolling 604800000 ms.\", \"Revision\": 1 }, \"Name\": \"CustomConfiguration\" } 자세한 내용은 Amazon Managed Streaming for Apache Kafka 개발자 안내서의 Amazon MSK 구 성 작업을 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 CreateConfiguration을 참조하세요. Amazon MSK 5035\n\n AWS Command Line Interface describe-cluster 버전 2 사용 설명서 다음 코드 예시에서는 describe-cluster의 사용 방법을 보여줍니다. AWS CLI 클러스터 설명 다음 describe-cluster 예시에서는 Amazon MSK 클러스터를 설명합니다. aws kafka describe-cluster \\ --cluster-arn arn:aws:kafka:us-east-1:123456789012:cluster/demo- cluster-1/6357e0b2-0e6a-4b86-a0b4-70df934c2e31-5 출력: { \"ClusterInfo\": { \"BrokerNodeGroupInfo\": { \"BrokerAZDistribution\": \"DEFAULT\", \"ClientSubnets\": [ \"subnet-cbfff283\", \"subnet-6746046b\" ], \"InstanceType\": \"kafka.m5.large\", \"SecurityGroups\": [ \"sg-f839b688\" ], \"StorageInfo\": { \"EbsStorageInfo\": { \"VolumeSize\": 100 } } }, \"ClusterArn\": \"arn:aws:kafka:us-east-1:123456789012:cluster/demo- cluster-1/6357e0b2-0e6a-4b86-a0b4-70df934c2e31-5\", \"ClusterName\": \"demo-cluster-1\", \"CreationTime\": \"2020-07-09T02:31:36.223000+00:00\", \"CurrentBrokerSoftwareInfo\": { \"KafkaVersion\": \"2.2.1\" }, \"CurrentVersion\": \"K3AEGXETSR30VB\", \"EncryptionInfo\": { Amazon MSK 5036\n\n AWS Command Line Interface 버전 2 사용 설명서 \"EncryptionAtRest\": { \"DataVolumeKMSKeyId\": \"arn:aws:kms:us-east-1:123456789012:key/ a7ca56d5-0768-4b64-a670-339a9fbef81c\" }, \"EncryptionInTransit\": { \"ClientBroker\": \"TLS_PLAINTEXT\", \"InCluster\": true } }, \"EnhancedMonitoring\": \"DEFAULT\", \"OpenMonitoring\": { \"Prometheus\": { \"JmxExporter\": { \"EnabledInBroker\": false }, \"NodeExporter\": { \"EnabledInBroker\": false } } }, \"NumberOfBrokerNodes\": 2, \"State\": \"ACTIVE\", \"Tags\": {}, \"ZookeeperConnectString\": \"z-2.demo-cluster-1.xuy0sb.c5.kafka.us- east-1.amazonaws.com:2181,z-1.demo-cluster-1.xuy0sb.c5.kafka.us- east-1.amazonaws.com:2181,z-3.demo-cluster-1.xuy0sb.c5.kafka.us- east-1.amazonaws.com:2181\" } } 자세한 내용은 Amazon Managed Streaming for Apache Kafka 개발자 안내서의 Amazon MSK 클 러스터 나열을 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 DescribeCluster를 참조하세요. get-bootstrap-brokers 다음 코드 예시에서는 get-bootstrap-brokers의 사용 방법을 보여줍니다. AWS CLI 부트스트랩 브로커 가져오기 Amazon MSK 5037\n\n AWS Command Line Interface 버전 2 사용 설명서 다음 get-bootstrap-brokers 예시에서는 Amazon MSK 클러스터의 부트스트랩 브로커 정보 를 가져옵니다. aws kafka get-bootstrap-brokers \\ --cluster-arn arn:aws:kafka:us-east-1:123456789012:cluster/demo- cluster-1/6357e0b2-0e6a-4b86-a0b4-70df934c2e31-5 출력: { \"BootstrapBrokerString\": \"b-1.demo-cluster-1.xuy0sb.c5.kafka.us- east-1.amazonaws.com:9092,b-2.demo-cluster-1.xuy0sb.c5.kafka.us- east-1.amazonaws.com:9092\", \"BootstrapBrokerStringTls\": \"b-1.demo-cluster-1.xuy0sb.c5.kafka.us- east-1.amazonaws.com:9094,b-2.demo-cluster-1.xuy0sb.c5.kafka.us- east-1.amazonaws.com:9094\" } 자세한 내용은 Amazon Managed Streaming for Apache Kafka 개발자 안내서의 부트스트랩 브로 커 가져오기를 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 GetBootstrapBrokers를 참조하세요. list-clusters 다음 코드 예시에서는 list-clusters의 사용 방법을 보여줍니다. AWS CLI 사용 가능한 클러스터 나열 다음 list-clusters 예시에서는 AWS 계정의 Amazon MSK 클러스터를 나열합니다. aws kafka list-clusters 출력: { \"ClusterInfoList\": [ { \"BrokerNodeGroupInfo\": { \"BrokerAZDistribution\": \"DEFAULT\", Amazon MSK 5038\n\n AWS Command Line Interface 버전 2 사용 설명서 \"ClientSubnets\": [ \"subnet-cbfff283\", \"subnet-6746046b\" ], \"InstanceType\": \"kafka.m5.large\", \"SecurityGroups\": [ \"sg-f839b688\" ], \"StorageInfo\": { \"EbsStorageInfo\": { \"VolumeSize\": 100 } } }, \"ClusterArn\": \"arn:aws:kafka:us-east-1:123456789012:cluster/demo- cluster-1/6357e0b2-0e6a-4b86-a0b4-70df934c2e31-5\", \"ClusterName\": \"demo-cluster-1\", \"CreationTime\": \"2020-07-09T02:31:36.223000+00:00\", \"CurrentBrokerSoftwareInfo\": { \"KafkaVersion\": \"2.2.1\" }, \"CurrentVersion\": \"K3AEGXETSR30VB\", \"EncryptionInfo\": { \"EncryptionAtRest\": { \"DataVolumeKMSKeyId\": \"arn:aws:kms:us-east-1:123456789012:key/ a7ca56d5-0768-4b64-a670-339a9fbef81c\" }, \"EncryptionInTransit\": { \"ClientBroker\": \"TLS_PLAINTEXT\", \"InCluster\": true } }, \"EnhancedMonitoring\": \"DEFAULT\", \"OpenMonitoring\": { \"Prometheus\": { \"JmxExporter\": { \"EnabledInBroker\": false }, \"NodeExporter\": { \"EnabledInBroker\": false } } }, \"NumberOfBrokerNodes\": 2, Amazon MSK 5039\n\n AWS Command Line\n\n내용은 Amazon Managed Streaming for Apache Kafka 개발자 안내서의 부트스트랩 브로 커 가져오기를 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 GetBootstrapBrokers를 참조하세요. list-clusters 다음 코드 예시에서는 list-clusters의 사용 방법을 보여줍니다. AWS CLI 사용 가능한 클러스터 나열 다음 list-clusters 예시에서는 AWS 계정의 Amazon MSK 클러스터를 나열합니다. aws kafka list-clusters 출력: { \"ClusterInfoList\": [ { \"BrokerNodeGroupInfo\": { \"BrokerAZDistribution\": \"DEFAULT\", Amazon MSK 5038\n\n AWS Command Line Interface 버전 2 사용 설명서 \"ClientSubnets\": [ \"subnet-cbfff283\", \"subnet-6746046b\" ], \"InstanceType\": \"kafka.m5.large\", \"SecurityGroups\": [ \"sg-f839b688\" ], \"StorageInfo\": { \"EbsStorageInfo\": { \"VolumeSize\": 100 } } }, \"ClusterArn\": \"arn:aws:kafka:us-east-1:123456789012:cluster/demo- cluster-1/6357e0b2-0e6a-4b86-a0b4-70df934c2e31-5\", \"ClusterName\": \"demo-cluster-1\", \"CreationTime\": \"2020-07-09T02:31:36.223000+00:00\", \"CurrentBrokerSoftwareInfo\": { \"KafkaVersion\": \"2.2.1\" }, \"CurrentVersion\": \"K3AEGXETSR30VB\", \"EncryptionInfo\": { \"EncryptionAtRest\": { \"DataVolumeKMSKeyId\": \"arn:aws:kms:us-east-1:123456789012:key/ a7ca56d5-0768-4b64-a670-339a9fbef81c\" }, \"EncryptionInTransit\": { \"ClientBroker\": \"TLS_PLAINTEXT\", \"InCluster\": true } }, \"EnhancedMonitoring\": \"DEFAULT\", \"OpenMonitoring\": { \"Prometheus\": { \"JmxExporter\": { \"EnabledInBroker\": false }, \"NodeExporter\": { \"EnabledInBroker\": false } } }, \"NumberOfBrokerNodes\": 2, Amazon MSK 5039\n\n AWS Command Line Interface 버전 2 사용 설명서 \"State\": \"ACTIVE\", \"Tags\": {}, \"ZookeeperConnectString\": \"z-2.demo-cluster-1.xuy0sb.c5.kafka.us- east-1.amazonaws.com:2181,z-1.demo-cluster-1.xuy0sb.c5.kafka.us- east-1.amazonaws.com:2181,z-3.demo-cluster-1.xuy0sb.c5.kafka.us- east-1.amazonaws.com:2181\" } ] } 자세한 내용은 Amazon Managed Streaming for Apache Kafka 개발자 안내서의 Amazon MSK 클 러스터 나열을 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 ListClusters를 참조하세요. update-broker-storage 다음 코드 예시에서는 update-broker-storage의 사용 방법을 보여줍니다. AWS CLI 브로커의 EBS 스토리지 업데이트 다음 update-broker-storage 예시에서는 클러스터 내 모든 브로커의 EBS 스토리지 양을 업데 이트합니다. Amazon MSK는 각 브로커의 목표 스토리지 양을 예시에 지정된 양으로 설정합니다. 클러스터를 설명하거나 모든 클러스터를 나열하여 클러스터의 현재 버전을 가져올 수 있습니다. aws kafka update-broker-storage \\ --cluster-arn \"arn:aws:kafka:us-west-2:123456789012:cluster/MessagingCluster/ a1b2c3d4-5678-90ab-cdef-11111EXAMPLE-2\" \\ --current-version \"K21V3IB1VIZYYH\" \\ --target-broker-ebs-volume-info \"KafkaBrokerNodeId=ALL,VolumeSizeGB=1100\" 출력은 이 update-broker-storage 작업에 대한 ARN을 반환합니다. 이 작업이 완료되었는지 확인하려면 이 ARN과 함께 describe-cluster-operation 명령을 입력으로 사용합니다. { \"ClusterArn\": \"arn:aws:kafka:us-west-2:123456789012:cluster/MessagingCluster/ a1b2c3d4-5678-90ab-cdef-11111EXAMPLE-2\", \"ClusterOperationArn\": \"arn:aws:kafka:us-west-2:123456789012:cluster- operation/V123450123/a1b2c3d4-1234-abcd-cdef-22222EXAMPLE-2/a1b2c3d4-abcd-1234- bcde-33333EXAMPLE\" Amazon MSK 5040\n\n AWS Command Line Interface } 버전 2 사용 설명서 자세한 내용은 Amazon Managed Streaming for Apache Kafka 개발자 안내서의 브로커의 EBS 스 토리지 업데이트를 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 UpdateBrokerStorage를 참조하세요. update-cluster-configuration 다음 코드 예시에서는 update-cluster-configuration의 사용 방법을 보여줍니다. AWS CLI Amazon MSK 클러스터 구성 업데이트 다음 update-cluster-configuration 예시에서는 지정된 기존 MSK 클러스터의 구성을 업데 이트합니다. 사용자 지정 MSK 구성을 사용합니다. aws kafka update-cluster-configuration \\ --cluster-arn \"arn:aws:kafka:us-west-2:123456789012:cluster/MessagingCluster/ a1b2c3d4-5678-90ab-cdef-11111EXAMPLE-2\" \\ --configuration-info file://configuration-info.json \\ --current-version \"K21V3IB1VIZYYH\" configuration-info.json의 콘텐츠: { \"Arn\": \"arn:aws:kafka:us-west-2:123456789012:configuration/CustomConfiguration/ a1b2c3d4-5678-90ab-cdef-11111EXAMPLE-2\", \"Revision\": 1 } 출력은 이 update-cluster-configuration 작업에 대한 ARN을 반환합니다. 이 작업이 완료 되었는지 확인하려면 이 ARN과 함께 describe-cluster-operation 명령을 입력으로 사용합 니다. { \"ClusterArn\": \"arn:aws:kafka:us-west-2:123456789012:cluster/MessagingCluster/ a1b2c3d4-5678-90ab-cdef-11111EXAMPLE-2\", \"ClusterOperationArn\": \"arn:aws:kafka:us-west-2:123456789012:cluster- operation/V123450123/a1b2c3d4-1234-abcd-cdef-22222EXAMPLE-2/a1b2c3d4-abcd-1234- bcde-33333EXAMPLE\" Amazon MSK 5041\n\n AWS Command Line Interface } 버전 2 사용 설명서 자세한 내용은 Amazon Managed Streaming for Apache Kafka 개발자 안내서의 Amazon MSK 클 러스터 구성 업데이트를 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 UpdateClusterConfiguration을 참조하세요. AWS CLI를 사용한 Network Flow Monitor 예제 다음 코드 예제에서는 Network Flow Monitor와 함께 AWS Command Line Interface를 사용하여 작업 을 수행하고 일반적인 시나리오를 구현하는 방법을 보여줍니다. 작업은 대규모 프로그램에서 발췌한 코드이며 컨텍스트에 맞춰 실행해야 합니다. 작업은 관련 시나리 오의 컨텍스트에 따라 표시되며, 개별 서비스 함수를 직접적으로 호출하는 방법을 보여줍니다. 각 예시에는 전체 소스 코드에 대한 링크가 포함되어 있으며, 여기에서 컨텍스트에 맞춰 코드를 설정하 고 실행하는 방법에 대한 지침을 찾을 수 있습니다. 주제 • 작업 작업 create-monitor 다음 코드 예시는 create-monitor의 사용 방법을 보여 줍니다. AWS CLI 모니터를 생성하려면 다음 create-monitor 예제에서는 지정된 계정에 demo라는 모니터를 생성합니다. aws networkflowmonitor create-monitor \\ --monitor-name demo \\ --local-resources type=\"AWS::EC2::VPC\",identifier=\"arn:aws:ec2:us- east-1:123456789012:vpc/vpc-03ea55eeda25adbb0\" \\ --scope-arn arn:aws:networkflowmonitor:us-east-1:123456789012:scope/ e21cda79-30a0-4c12-9299-d8629d76d8cf Network Flow Monitor 5042\n\n AWS Command Line Interface 버전 2 사용 설명서 출력: { \"monitorArn\": \"arn:aws:networkflowmonitor:us-east-1:123456789012:monitor/demo\", \"monitorName\": \"demo\", \"monitorStatus\": \"ACTIVE\", \"tags\": {} } 자세한 내용은 Amazon CloudWatch 사용 설명서에서 Network Flow Monitor에서 모니터 생성을 참 조하세요. • API 세부 정보는 AWS CLI 명령 참조의 CreateMonitor를 참조하세요. create-scope 다음 코드 예시는 create-scope의 사용 방법을 보여 줍니다. AWS CLI 범위를 생성하려면 다음 create-scope 예제에서는 Network Flow Monitor가 네트워크 트래픽 지표를 생성할 리소스 세트를 포함하는 범위를 생성합니다. aws networkflowmonitor create-scope \\ --targets '[{\"targetIdentifier\":{\"targetId\": {\"accountId\":\"123456789012\"},\"targetType\":\"ACCOUNT\"},\"region\":\"us-east-1\"}]' 출력: { \"scopeId\": \"97626f8d-8a21-4b5d-813a-1a0962dd4615\", \"status\": \"IN_PROGRESS\", \"tags\": {} } 자세한 내용은 Amazon CloudWatch 사용 설명서에서 Network Flow Monitor의 구성 요소 및 기 능을 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 CreateScope 섹션을 참조하세요. Network Flow Monitor 5043\n\n AWS Command Line Interface delete-monitor 다음 코드 예시는 delete-monitor의 사용 방법을 보여 줍니다. 버전 2 사용 설명서 AWS CLI 모니터 삭제 다음 delete-monitor 예제에서는 지정된 계정에서 demo라는 모니터를 삭제합니다. aws networkflowmonitor delete-monitor \\ --monitor-name demo 이 명령은 출력을 생성하지 않습니다. 자세한 내용은 Amazon CloudWatch 사용 설명서의 Network Flow Monitor에서 모니터 삭제를 참조 하세요. • API 세부 정보는 AWS CLI 명령 참조의 DeleteMonitor를 참조하세요. delete-scope 다음 코드 예시는 delete-scope의 사용 방법을 보여 줍니다. AWS CLI 범위를 삭제하려면 다음 delete-scope 예제에서는 지정된 범위를 삭제합니다. aws networkflowmonitor delete-scope \\ --scope-id fdc20616-6bb4-4242-a24e-a748e65ca7ac 이 명령은 출력을 생성하지 않습니다. 자세한 내용은 Amazon CloudWatch 사용 설명서에서 Network Flow Monitor의 구성 요소 및 기 능을 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 DeleteScope를 참조하세요. get-monitor 다음 코드 예시는 get-monitor의 사용 방법을 보여 줍니다. Network Flow Monitor 5044\n\n AWS Command Line Interface AWS CLI 모니터 정보를 검색하려면 버전 2 사용 설명서 다음 get-monitor 예제는 지정된 계정에서 demo라는 모니터에 대한 정보를 표시합니다. aws networkflowmonitor get-monitor \\ --monitor-name Demo 출력: { \"monitorArn\": \"arn:aws:networkflowmonitor:us-east-1:123456789012:monitor/Demo\", \"monitorName\": \"Demo\", \"monitorStatus\": \"ACTIVE\", \"localResources\": [ { \"type\": \"AWS::EC2::VPC\", \"identifier\": \"arn:aws:ec2:us-east-1:123456789012:vpc/ vpc-03ea55eeda25adbb0\" } ], \"remoteResources\": [], \"createdAt\": \"2024-12-09T12:21:51.616000-06:00\", \"modifiedAt\": \"2024-12-09T12:21:55.412000-06:00\", \"tags\": {} } 자세한 내용은 Amazon CloudWatch 사용 설명서에서 Network Flow Monitor의 구성 요소 및 기 능을 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 GetMonitor를 참조하세요. get-query-results-workload-insights-top-contributors-data 다음 코드 예시는 get-query-results-workload-insights-top-contributors-data의 사 용 방법을 보여 줍니다."}, {"ref": "/docs/aurora-ug.pdf", "chunk_id": "aws/aurora-ug_pdf#chunk080", "doc_id": "aws/aurora-ug_pdf", "page": 314, "anchor": "사용합니다. • 데이터베이스의 메이저 엔진 버전이 RDS 표준 지원 종료일에 다다른 경우 추가 지원 CLI 옵션 또는 RDS API 파라미터를 사용해야 합니다. 자세한 내용은 Aurora DB 클러스터 설정의 RDS 추가 지원 을 참조하세요. DB 클러스터 생성 AWS Management Console, AWS CLI 또는 RDS API를 사용하여 Aurora DB 클러스터를 생성할 수 있 습니다. 콘솔 손쉬운 생성의 활성화 여부와 관계없이 AWS Management Console을 사용하여 DB 클러스터를 생성 할 수 있습니다. Easy create(간편 생성)를 활성화한 경우에는 DB 엔진 유형, DB 인스턴스 크기 및 DB 인스턴스 식별자만 지정합니다. Easy create(간편 생성)는 다른 구성 옵션에서도 기본 설정을 사용합니 다. Easy create(간편 생성)가 활성화되지 않은 경우에는 데이터베이스를 생성할 때 가용성, 보안, 백업 및 유지 관리에 대한 옵션을 포함하여 더 많은 구성 옵션을 지정합니다. Note 이 예에서는 [표준 생성(Standard Create)]이 활성화되고 [간편 생성(Easy Create)]은 활성화 되지 않습니다. 손쉬운 생성을 활성화한 상태에서 DB 클러스터를 생성하는 방법은 Amazon Aurora 시작하기 섹션을 참조하세요. DB 클러스터 생성 271\n\n Amazon Aurora Aurora 사용 설명서 콘솔을 사용하여 Aurora DB 클러스터를 생성하려면 1. AWS Management Console에 로그인한 후 https://console.aws.amazon.com/rds/에서 Amazon RDS 콘솔을 엽니다. 2. AWS Management Console의 오른쪽 상단 모서리에서 DB 인스턴스를 생성하려는 AWS 리전을 선택합니다. 일부 AWS 리전에서는 Aurora를 사용할 수 없습니다. Aurora를 사용할 수 있는 AWS 리전 목록은 리전 가용성 섹션을 참조하세요. 3. 탐색 창에서 데이터베이스를 선택합니다. 4. 데이터베이스 생성을 선택합니다. 5. 데이터베이스 생성 방법 선택에서 표준 생성을 선택합니다. 6. 캐시 유형에서 다음 중 하나를 선택합니다. • Aurora(MySQL 호환) • Aurora(PostgreSQL 호환) DB 클러스터 생성 272\n\n Amazon Aurora Aurora 사용 설명서 7. 엔진 버전을 선택합니다. 자세한 내용은 Amazon Aurora 섹션을 참조하세요. 필터를 사용하여 원하는 기능(예: Aurora Serverless v2)과 호환되는 버전을 선택할 수 있습니다. 자세한 내용은 Aurora Serverless v2 사용 하기 섹션을 참조하세요. 8. 템플릿에서 사용 사례에 맞는 템플릿을 선택합니다. 9. 마스터 암호를 입력하려면 다음과 같이 하세요. a. 설정 섹션에서 보안 인증 정보 설정을 엽니다. DB 클러스터 생성 273\n\n Amazon Aurora Aurora 사용 설명서 b. Auto generate a password(암호 자동 생성) 확인란의 선택을 취소합니다. c. (선택 사항) 마스터 사용자 이름 값을 변경하고 마스터 암호 및 암호 확인에 동일한 암호를 입 력합니다. 기본적으로 새 DB 인스턴스는 마스터 사용자를 위해 자동 생성된 암호를 사용합니다. 10. VPC 보안 그룹(방화벽) 아래의 연결 섹션에서 새로 만들기를 선택하면 로컬 컴퓨터의 IP 주소가 데이터베이스에 액세스할 수 있도록 허용하는 인바운드 규칙과 함께 VPC 보안 그룹이 생성됩니 다. 11. 클러스터 스토리지 구성의 경우 Aurora I/O-Optimized 또는 Aurora Standard 중 하나를 선택합니 다. 자세한 내용은 Amazon Aurora DB 클러스터의 스토리지 구성 섹션을 참조하세요. 12. (선택 사항) 이 DB 클러스터의 컴퓨팅 리소스에 대한 연결을 설정합니다. DB 클러스터를 생성하는 동안 Amazon EC2 인스턴스와 새 DB 클러스터 간의 연결을 구성할 수 있습니다. 자세한 내용은 EC2 인스턴스와의 자동 네트워크 연결 구성 섹션을 참조하세요. 13. 나머지 섹션에서 DB 클러스터 설정을 지정합니다. 각 설정에 대한 자세한 내용은 Aurora DB 클러 스터 설정 단원을 참조하십시오. 14. 데이터베이스 생성을 선택합니다. 자동 생성된 암호를 사용하기로 한 경우에는 Databases(데이터베이스) 페이지에 View credential details(자격 증명 세부 정보 보기) 버튼이 나타납니다. DB 클러스터의 마스터 사용자 이름 및 암호를 보려면 자격 증명 세부 정보 보기를 선택합니다. DB 인스턴스를 마스터 사용자로 연결하려면 화면에 나타난 사용자 이름과 암호를 사용합니다. DB 클러스터 생성 274\n\n Amazon Aurora Aurora 사용 설명서 Important 마스터 사용자 암호를 다시 볼 수는 없습니다. 따라서 기록을 해두지 않으면 이를 변경해 야 합니다. DB 인스턴스가 사용 가능한 상태가 되고 난 후에 마스터 사용자 암호를 변경해 야 하는 경우에는 다음과 같은 방법으로 DB 인스턴스를 수정할 수 있습니다. DB 인스턴스 변경에 대한 자세한 내용은 Amazon Aurora DB 클러스터 수정 단원을 참조하십시오. 15. 데이터베이스에서 새 Aurora DB 클러스터의 이름을 선택합니다. RDS 콘솔에 새 DB 인스턴스의 세부 정보가 표시됩니다. DB 클러스터를 사용할 준비가 될 때까지 DB 클러스터와 그 DB 인스턴스의 상태는 생성 중입니다. 둘 모두의 상태가 사용 가능으로 변경되면 DB 인스턴스에 연결할 수 있습니다. DB 인스턴스 클래 스와 스토리지의 용량에 따라 새 DB 인스턴스를 사용할 수 있을 때까지 최대 20분이 걸릴 수 있습 니다. 새로 생성된 클러스터를 보려면 Amazon RDS 콘솔의 탐색 창에서 데이터베이스를 선택합니다. 그런 다음, DB 클러스터 세부 정보를 표시할 DB 클러스터를 선택합니다. 자세한 내용은 Amazon Aurora DB 클러스터 보기 섹션을 참조하세요. DB 클러스터 생성 275\n\n Amazon Aurora Aurora 사용 설명서 Connectivity & security(연결 및 보안) 탭에서 라이터 DB 인스턴스의 포트 및 엔드포인트를 적어둡 니다. 쓰기 또는 읽기 작업을 수행하는 애플리케이션은 모두 JDBC 및 ODBC 연결 문자열에 이 클 러스터의 엔드포인트와 포트를 사용합니다. AWS CLI Note AWS CLI를 사용해 Aurora DB 클러스터를 새로 만들기 전에 반드시 VPC 및 RDS DB 서브넷 그룹 생성 같은 필수 사전 조건을 충족해야 합니다. 자세한 내용은 DB 클러스터 사전 조건 섹 션을 참조하세요. DB 클러스터 생성 276\n\n Amazon Aurora Aurora 사용 설명서 AWS CLI를 사용하여 Aurora MySQL DB 클러스터 또는 Aurora PostgreSQL DB 클러스터를 생성할 수 있습니다. AWS CLI를 사용하여 Aurora MySQL DB 클러스터를 생성하려면 Aurora MySQL 8.0 또는 5.7 호환 DB 클러스터 또는 DB 인스턴스를 생성할 때는 --engine 옵션에 aurora-mysql을 지정해야 합니다. 다음 단계를 완료합니다. 1. 새 DB 클러스터에 대한 DB 서브넷 그룹과 VPC 보안 그룹 ID를 확인한 다음 create-db-cluster AWS CLI 명령을 호출하여 Aurora MySQL DB 클러스터를 생성하세요. 예를 들어, 다음 명령을 사용하면 이름이 sample-cluster인 새 MySQL 8.0 호환 DB 클러스터 가 생성됩니다. 클러스터는 기본 엔진 버전 및 Aurora I/O-Optimized 스토리지 유형을 사용합니다. 대상 LinuxmacOS, 또는Unix: aws rds create-db-cluster --db-cluster-identifier sample-cluster \\ --engine aurora-mysql --engine-version 8.0 \\ --storage-type aurora-iopt1 \\ --master-username user-name --manage-master-user-password \\ --db-subnet-group-name mysubnetgroup --vpc-security-group-ids sg-c7e5b0d2 Windows의 경우: aws rds create-db-cluster --db-cluster-identifier sample-cluster ^ --engine aurora-mysql --engine-version 8.0 ^ --storage-type aurora-iopt1 ^ --master-username user-name --manage-master-user-password ^ --db-subnet-group-name mysubnetgroup --vpc-security-group-ids sg-c7e5b0d2 다음 명령을 사용하면 이름이 sample-cluster인 새 MySQL 5.7 호환 DB 클러스터가 생성됩니 다. 클러스터는 기본 엔진 버전 및\n\nDB 클러스터를 생성할 수 있습니다. AWS CLI를 사용하여 Aurora MySQL DB 클러스터를 생성하려면 Aurora MySQL 8.0 또는 5.7 호환 DB 클러스터 또는 DB 인스턴스를 생성할 때는 --engine 옵션에 aurora-mysql을 지정해야 합니다. 다음 단계를 완료합니다. 1. 새 DB 클러스터에 대한 DB 서브넷 그룹과 VPC 보안 그룹 ID를 확인한 다음 create-db-cluster AWS CLI 명령을 호출하여 Aurora MySQL DB 클러스터를 생성하세요. 예를 들어, 다음 명령을 사용하면 이름이 sample-cluster인 새 MySQL 8.0 호환 DB 클러스터 가 생성됩니다. 클러스터는 기본 엔진 버전 및 Aurora I/O-Optimized 스토리지 유형을 사용합니다. 대상 LinuxmacOS, 또는Unix: aws rds create-db-cluster --db-cluster-identifier sample-cluster \\ --engine aurora-mysql --engine-version 8.0 \\ --storage-type aurora-iopt1 \\ --master-username user-name --manage-master-user-password \\ --db-subnet-group-name mysubnetgroup --vpc-security-group-ids sg-c7e5b0d2 Windows의 경우: aws rds create-db-cluster --db-cluster-identifier sample-cluster ^ --engine aurora-mysql --engine-version 8.0 ^ --storage-type aurora-iopt1 ^ --master-username user-name --manage-master-user-password ^ --db-subnet-group-name mysubnetgroup --vpc-security-group-ids sg-c7e5b0d2 다음 명령을 사용하면 이름이 sample-cluster인 새 MySQL 5.7 호환 DB 클러스터가 생성됩니 다. 클러스터는 기본 엔진 버전 및 Aurora Standard 스토리지 유형을 사용합니다. 대상 LinuxmacOS, 또는Unix: aws rds create-db-cluster --db-cluster-identifier sample-cluster \\ --engine aurora-mysql --engine-version 5.7 \\ --storage-type aurora \\ --master-username user-name --manage-master-user-password \\ DB 클러스터 생성 277\n\n Amazon Aurora Aurora 사용 설명서 --db-subnet-group-name mysubnetgroup --vpc-security-group-ids sg-c7e5b0d2 Windows의 경우: aws rds create-db-cluster --db-cluster-identifier sample-cluster sample-cluster ^ --engine aurora-mysql --engine-version 5.7 ^ --storage-type aurora ^ --master-username user-name --manage-master-user-password ^ --db-subnet-group-name mysubnetgroup --vpc-security-group-ids sg-c7e5b0d2 2. 콘솔을 사용하여 DB 클러스터를 생성하면 Amazon RDS에서 자동으로 DB 클러스터를 위한 기본 인스턴스(라이터)를 생성합니다. AWS CLI를 사용하여 DB 클러스터를 생성할 경우 반드시 DB 클 러스터를 위한 기본 인스턴스를 명시적으로 생성해야 합니다. 기본 인스턴스는 클러스터에 생성 된 최초의 DB 인스턴스입니다. 프라이머리 DB 인스턴스를 만들 때까지 DB 클러스터 엔드포인트 는 Creating 상태를 유지합니다. create-db-instanceAWS CLI 명령을 호출하여 DB 클러스터를 위한 기본 인스턴스를 생성하세요. DB 클러스터의 이름을 --db-cluster-identifier 옵션 값으로 포함하세요. Note DB 인스턴스의 --storage-type 옵션은 설정할 수 없습니다. DB 클러스터에만 설정할 수 있습니다. 예를 들어, 다음 명령을 사용하면 이름이 sample-instance인 새 MySQL 5.7 또는 8.0 호환 DB 인스턴스가 생성됩니다. 대상 LinuxmacOS, 또는Unix: aws rds create-db-instance --db-instance-identifier sample-instance \\ --db-cluster-identifier sample-cluster --engine aurora-mysql --db-instance- class db.r5.large Windows의 경우: aws rds create-db-instance --db-instance-identifier sample-instance ^ --db-cluster-identifier sample-cluster --engine aurora-mysql --db-instance- class db.r5.large DB 클러스터 생성 278\n\n Amazon Aurora Aurora 사용 설명서 AWS CLI를 사용하여 Aurora PostgreSQL DB 클러스터를 생성하려면 1. 새 DB 클러스터에 대한 DB 서브넷 그룹과 VPC 보안 그룹 ID를 확인한 다음 create-db-cluster AWS CLI 명령을 호출하여 Aurora PostgreSQL DB 클러스터를 생성하세요. 예를 들어, 다음 명령을 사용하면 이름이 sample-cluster인 새 DB 클러스터가 생성됩니다. 클 러스터는 기본 엔진 버전 및 Aurora I/O-Optimized 스토리지 유형을 사용합니다. 대상 LinuxmacOS, 또는Unix: aws rds create-db-cluster --db-cluster-identifier sample-cluster \\ --engine aurora-postgresql \\ --storage-type aurora-iopt1 \\ --master-username user-name --manage-master-user-password \\ --db-subnet-group-name mysubnetgroup --vpc-security-group-ids sg-c7e5b0d2 Windows의 경우: aws rds create-db-cluster --db-cluster-identifier sample-cluster ^ --engine aurora-postgresql ^ --storage-type aurora-iopt1 ^ --master-username user-name --manage-master-user-password ^ --db-subnet-group-name mysubnetgroup --vpc-security-group-ids sg-c7e5b0d2 2. 콘솔을 사용하여 DB 클러스터를 생성하면 Amazon RDS에서 자동으로 DB 클러스터를 위한 기본 인스턴스(라이터)를 생성합니다. AWS CLI를 사용하여 DB 클러스터를 생성할 경우 반드시 DB 클 러스터를 위한 기본 인스턴스를 명시적으로 생성해야 합니다. 기본 인스턴스는 클러스터에 생성 된 최초의 DB 인스턴스입니다. 프라이머리 DB 인스턴스를 만들 때까지 DB 클러스터 엔드포인트 는 Creating 상태를 유지합니다. create-db-instanceAWS CLI 명령을 호출하여 DB 클러스터를 위한 기본 인스턴스를 생성하세요. DB 클러스터의 이름을 --db-cluster-identifier 옵션 값으로 포함하세요. 대상 LinuxmacOS, 또는Unix: aws rds create-db-instance --db-instance-identifier sample-instance \\ --db-cluster-identifier sample-cluster --engine aurora-postgresql --db- instance-class db.r5.large Windows의 경우: DB 클러스터 생성 279\n\n Amazon Aurora Aurora 사용 설명서 aws rds create-db-instance --db-instance-identifier sample-instance ^ --db-cluster-identifier sample-cluster --engine aurora-postgresql --db- instance-class db.r5.large 이 예제에서는 마스터 사용자 암호를 생성하고 이를 Secrets Manager에서 관리하는 --manage- master-user-password 옵션도 지정합니다. 자세한 내용은 Amazon Aurora 및 AWS Secrets Manager를 통한 암호 관리 섹션을 참조하세요. 또는 --master-password 옵션을 사용하여 암호를 직접 지정하고 관리할 수 있습니다. RDS API Note AWS CLI를 사용해 Aurora DB 클러스터를 새로 만들기 전에 반드시 VPC 및 RDS DB 서브넷 그룹 생성 같은 필수 사전 조건을 충족해야 합니다. 자세한 내용은 DB 클러스터 사전 조건 섹 션을 참조하세요. 새 DB 클러스터에 대한 DB 서브넷 그룹과 VPC 보안 그룹 ID를 확인한 다음 CreateDBCluster 작업을 호출하여 DB 클러스터를 생성하십시오. Aurora MySQL 버전 2 또는 3 DB 클러스터 또는 DB 인스턴스를 생성할 때는 Engine 파라미터에 aurora-mysql을 지정해야 합니다. Aurora PostgreSQL DB 클러스터 또는 DB 인스턴스를 생성할 때는 aurora-postgresql 파라미터 에 Engine을 지정하세요. 콘솔을 사용하여 DB 클러스터를 생성하면 Amazon RDS에서 자동으로 DB 클러스터를 위한 기 본 인스턴스(라이터)를 생성합니다. RDS API를 사용하여 DB 클러스터를 생성할 경우 반드시 CreateDBInstance를 사용하여 DB 클러스터를 위한 프라이머리 인스턴스를 명시적으로 생성해야 합 니다. 기본 인스턴스는 클러스터에 생성된 최초의 DB 인스턴스입니다. 프라이머리 DB 인스턴스를 만 들 때까지 DB 클러스터 엔드포인트는 Creating 상태를 유지합니다. 기본(라이터) DB 인스턴스 생성 AWS Management Console을 사용하여 DB 클러스터를 생성하면 Amazon RDS에서 자동으로 DB 클 러스터를 위한 기본 인스턴스(라이터)를 생성합니다. AWS CLI 또는 RDS API를 사용하여 DB 클러스 터를 생성할 경우 반드시 DB 클러스터를 위한 기본 인스턴스를 명시적으로 생성해야 합니다. 기본 인 DB 클러스터 생성 280\n\n Amazon Aurora Aurora 사용 설명서 스턴스는 클러스터에 생성된 최초의 DB 인스턴스입니다. 프라이머리 DB 인스턴스를 만들 때까지 DB 클러스터 엔드포인트는 Creating 상태를 유지합니다. 자세한 내용은 DB 클러스터 생성 섹션을 참조하세요. Note 라이터 DB 인스턴스가 없는 DB 클러스터(‘헤드리스 클러스터’라고도 함)가 있는 경우 콘솔을 사용하여 라이터 인스턴스를 생성할 수 없습니다. AWS CLI 또는 RDS API를 사용해야 합니다. 다음 예제에서는 create-db-instance AWS CLI 명령을 사용하여 이름이 headless-test로 지정된 Aurora PostgreSQL DB 클러스터의 라이터 인스턴스를 생성합니다. aws rds create-db-instance \\ --db-instance-identifier no-longer-headless \\ --db-cluster-identifier headless-test \\ --engine aurora-postgresql \\ --db-instance-class db.t4g.medium Aurora DB 클러스터 설정 다음 테이블에는 Aurora DB 인스턴스를 생성할 때 선택하는 설정에 대한 세부 정보가 나와 있습니다. 콘솔 설정 설정 설명 CLI\n\nDB 클러스터를 생성하면 Amazon RDS에서 자동으로 DB 클 러스터를 위한 기본 인스턴스(라이터)를 생성합니다. AWS CLI 또는 RDS API를 사용하여 DB 클러스 터를 생성할 경우 반드시 DB 클러스터를 위한 기본 인스턴스를 명시적으로 생성해야 합니다. 기본 인 DB 클러스터 생성 280\n\n Amazon Aurora Aurora 사용 설명서 스턴스는 클러스터에 생성된 최초의 DB 인스턴스입니다. 프라이머리 DB 인스턴스를 만들 때까지 DB 클러스터 엔드포인트는 Creating 상태를 유지합니다. 자세한 내용은 DB 클러스터 생성 섹션을 참조하세요. Note 라이터 DB 인스턴스가 없는 DB 클러스터(‘헤드리스 클러스터’라고도 함)가 있는 경우 콘솔을 사용하여 라이터 인스턴스를 생성할 수 없습니다. AWS CLI 또는 RDS API를 사용해야 합니다. 다음 예제에서는 create-db-instance AWS CLI 명령을 사용하여 이름이 headless-test로 지정된 Aurora PostgreSQL DB 클러스터의 라이터 인스턴스를 생성합니다. aws rds create-db-instance \\ --db-instance-identifier no-longer-headless \\ --db-cluster-identifier headless-test \\ --engine aurora-postgresql \\ --db-instance-class db.t4g.medium Aurora DB 클러스터 설정 다음 테이블에는 Aurora DB 인스턴스를 생성할 때 선택하는 설정에 대한 세부 정보가 나와 있습니다. 콘솔 설정 설정 설명 CLI 옵션 및 RDS API 파라미터 자동 마이너 버전 업그 레이드 DB 엔진에 대한 기본 마이너 버전 업그레이드가 있을 때 Aurora DB Aurora 클러스터의 모든 DB 인스턴 스에 대해 이 값을 설정합니다. 클 클러스터에서 이를 자동으로 수신 러스터의 DB 인스턴스에서 이 설정 하도록 하려면 마이너 버전 자동 업 이 꺼져 있으면 클러스터가 자동으 그레이드 사용을 선택합니다. 로 업그레이드되지 않습니다. 마이너 버전 자동 업그레이드 설정 은 Aurora PostgreSQL 및 Aurora MySQL DB 클러스터 모두에 적용 AWS CLI를 사용하여 create- db-instance 를 실행하고 --auto-minor-version- 됩니다. Aurora PostgreSQL의 엔진 업데이 트에 대한 자세한 내용은 Amazon upgrade|--no-auto- minor-version-upgrade 옵 션을 설정합니다. 사용 가능한 설정 281\n\n Amazon Aurora Aurora 사용 설명서 콘솔 설정 설정 설명 CLI 옵션 및 RDS API 파라미터 Aurora PostgreSQL에 대한 데이터 베이스 엔진 업데이트 단원을 참조 하세요. RDS API를 사용하여 CreateDBI nstance 를 호출하고 AutoMinorVersionUpgrade AWS KMS key Aurora MySQL의 엔진 업데이트 에 대한 자세한 내용은 Amazon Aurora MySQL에 대한 데이터베이 스 엔진 업데이트 단원을 참조하세 요. Encryption(암호화)를 Enable encryption(암호화 활성화)으로 설 정한 경우에만 사용할 수 있습니 다. 이 DB 클러스터를 암호화하는 데 사용할 AWS KMS key을(를) 선 택합니다. 자세한 내용은 Amazon Aurora 리소스 암호화 섹션을 참조 하세요. 파라미터를 설정합니다. AWS CLI를 사용하여 create-db -cluster 를 실행하고 --kms- key-id 옵션을 설정합니다. RDS API를 사용하여 CreateDBC luster 를 호출하고 KmsKeyId 파라미터를 설정합니다. 역추적 Aurora MySQL에만 적용됩니다. 역추적을 활성화하려면 Enable Backtrack(역추적 활성화)을 선 AWS CLI를 사용하여 create- db-cluster 를 실행하고 -- backtrack-window 옵션을 설 택하고 역추적을 비활성화하려면 정합니다. RDS API를 사용하여 CreateDBC luster 를 호출하고 Backtrack Window 파라미터를 설정합니다. Disable Backtrack(역추적 비활성 화)을 선택합니다. 역추적을 이용하 면 새 DB 클러스터를 만들지 않고 특정 시점으로 DB 클러스터를 되감 을 수 있습니다. 기본적으로는 비활 성화되어 있습니다. 역추적을 활성 화할 경우 DB 클러스터를 역추적할 수 있는 기간(대상 역추적 기간)도 함께 지정하십시오. 자세한 내용은 Aurora DB 클러스터 역추적 섹션을 참조하세요. 사용 가능한 설정 282\n\n Amazon Aurora 콘솔 설정 인증 기관 설정 설명 CLI 옵션 및 RDS API 파라미터 Aurora 사용 설명서 DB 클러스터의 DB 인스턴스에서 사용하는 서버 인증서의 CA(인증 기관)입니다. 자세한 내용은 SSL/TLS를 사용하 여 DB 클러스터에 대한 연결 암호 화 섹션을 참조하세요. 클러스터 스토리지 구 성 DB 클러스터의 스토리지 유형 (Aurora I/O-Optimized 또는 Aurora Standard)입니다. 자세한 내용은 Amazon Aurora DB 클러스터의 스토리지 구성 섹션을 참조하세요. 스냅샷으로 태그 복사 스냅샷을 생성할 때 DB 인스턴스 태그를 DB 스냅샷에 복사하려면 이 옵션을 선택합니다. 자세한 내용은 Amazon Aurora 및 Amazon RDS 리소스에 태그 지정 섹션을 참조하세요. AWS CLI를 사용하여 create-db -instance 를 실행하고 --ca- certificate-identifier 옵션을 설정합니다. RDS API를 사용하여 CreateDBI nstance 를 호출하고 CACertificateIdentifier 파라미터를 설정합니다. AWS CLI를 사용하여 create- db-cluster 를 실행하고 -- storage-type 옵션을 설정합니 다. RDS API를 사용하여 CreateDBC luster 를 호출하고 StorageTy pe 파라미터를 설정합니다. AWS CLI를 사용하여 create- db-cluster 를 실행하고 -- copy-tags-to-snapshot | --no-copy-tags-to- snapshot 옵션을 설정합니다. RDS API를 사용하여 CreateDBC luster 를 호출하고 CopyTagsT oSnapshot 파라미터를 설정합 니다. 사용 가능한 설정 283\n\n Amazon Aurora Aurora 사용 설명서 콘솔 설정 설정 설명 CLI 옵션 및 RDS API 파라미터 AWS CLI에서 IAM 데이터베이 스 인증을 사용하려면 create- db-cluster 를 실행하고 -- enable-iam-database- authentication | --no- enable-iam-database-au thentication 옵션을 설정합 니다. RDS API에서 IAM 데이터베이스 인증을 사용하려면 CreateDBC luster 를 호출하고 EnableIAM DatabaseAuthentication 파라미터를 설정합니다. AWS CLI에서 Kerberos 인증 을 사용하려면 create-db- cluster를 실행하고 --domain 및 --domain-iam-role- name 옵션을 설정합니다. RDS API에서 Kerberos 인증을 사 용하려면 CreateDBCluster 를 호출하고 Domain 및 DomainIAM RoleName 파라미터를 설정합니 다. 데이터베이스 인증 사용하고자 하는 데이터베이스 인 증입니다. MySQL의 경우: • 데이터베이스 암호로만 데이터베 이스 사용자를 인증할 수 있도록 Password authentication(암호 인 증)을 선택합니다. • IAM 사용자 및 역할을 통해 데이 터베이스 암호 및 사용자 자격 증 명으로 데이터베이스 사용자를 인증하려면 [암호 및 IAM 데이터 베이스 인증(Password and IAM database authentication)]을 선택 합니다. 자세한 내용은 IAM 데이 터베이스 인증 섹션을 참조하세 요. PostgreSQL의 경우: • IAM 사용자 및 역할을 통해 데 이터베이스 암호 및 사용자 자 격 증명으로 데이터베이스 사용 자를 인증하려면 IAM database authentication(IAM 데이터베이 스 인증)을 선택합니다. 자세한 내용은 IAM 데이터베이스 인증 섹션을 참조하세요. • Kerberos 인증을 사용하여 데 이터베이스 암호 및 사용자 자 격 증명을 인증하려면 [Kerberos authentication(Kerberos 인증)] 을 선택합니다. 자세한 내용 은 Aurora PostgreSQL과 함께 사용 가능한 설정 284\n\n Amazon Aurora Aurora 사용 설명서 콘솔 설정 설정 설명 CLI 옵션 및 RDS API 파라미터 Kerberos 인증 사용 섹션을 참조 하세요. 데이터베이스 포트 애플리케이션과 유틸리티가 데이 터베이스에 액세스할 때 사용할 포 트를 지정합니다. Aurora MySQL AWS CLI를 사용하여 create-db -cluster 를 실행하고 --port 옵션을 설정합니다. RDS API를 사용하여 CreateDBC luster 를 호출하고 Port 파라미 터를 설정합니다. DB 클러스터는 기본 MySQL 포 트(3306)으로, 그리고 Aurora PostgreSQL DB 클러스터는 기본 PostgreSQL 포트(5432)로 기본 설 정됩니다. 일부 기업에서는 방화벽 이 이러한 기본"}, {"ref": "/docs/aws-cli_pdf_cli-chap-welcome.pdf", "chunk_id": "aws/aws-cli_pdf_cli-chap-welcome_pdf#chunk125", "doc_id": "aws/aws-cli_pdf_cli-chap-welcome_pdf", "page": 540, "anchor": "AWS Command Line Interface 버전 2 사용 설명서 출력: { \"mesh\":{ \"meshName\":\"app1\", \"metadata\":{ \"arn\":\"arn:aws:appmesh:us-east-1:123456789012:mesh/app1\", \"createdAt\":1563809909.282, \"lastUpdatedAt\":1563809909.282, \"uid\":\"a1b2c3d4-5678-90ab-cdef-11111EXAMPLE\", \"version\":1 }, \"spec\":{}, \"status\":{ \"status\":\"ACTIVE\" } } } 예제 2: 여러 태그가 포함된 새 서비스 메시를 생성하는 방법 다음 create-mesh 예제에서는 여러 태그가 있는 서비스 메시를 생성합니다. aws appmesh create-mesh \\ --mesh-name app2 \\ --tags key=key1,value=value1 key=key2,value=value2 key=key3,value=value3 출력: { \"mesh\":{ \"meshName\":\"app2\", \"metadata\":{ \"arn\":\"arn:aws:appmesh:us-east-1:123456789012:mesh/app2\", \"createdAt\":1563822121.877, \"lastUpdatedAt\":1563822121.877, \"uid\":\"a1b2c3d4-5678-90ab-cdef-11111EXAMPLE\", \"version\":1 }, \"spec\":{}, \"status\":{ \"status\":\"ACTIVE\" App Mesh 517\n\n AWS Command Line Interface 버전 2 사용 설명서 } } } 자세한 내용은 AWS App Mesh 사용 설명서의 서비스 메시를 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 CreateMesh를 참조하세요. create-route 다음 코드 예시는 create-route의 사용 방법을 보여 줍니다. AWS CLI 새 gRPC 경로를 생성하는 방법 다음 create-route 예제에서는 JSON 입력 파일을 사용하여 gRPC 경로를 생성합니다. 메타데 이터가 123으로 시작하는 GRPC 트래픽이 serviceBgrpc라는 이름의 가상 노드로 라우팅됩니다. 이 경로의 대상과 통신을 시도할 때 특정 gRPC, HTTP 또는 TCP 실패가 발생하는 경우 경로가 3회 재 시도됩니다. 각 재시도 사이에 15초의 지연이 발생합니다. aws appmesh create-route \\ --cli-input-json file://create-route-grpc.json create-route-grpc.json의 콘텐츠: { \"meshName\" : \"apps\", \"routeName\" : \"grpcRoute\", \"spec\" : { \"grpcRoute\" : { \"action\" : { \"weightedTargets\" : [ { \"virtualNode\" : \"serviceBgrpc\", \"weight\" : 100 } ] }, \"match\" : { \"metadata\" : [ { App Mesh 518\n\n AWS Command Line Interface 버전 2 사용 설명서 \"invert\" : false, \"match\" : { \"prefix\" : \"123\" }, \"name\" : \"myMetadata\" } ], \"methodName\" : \"GetColor\", \"serviceName\" : \"com.amazonaws.services.ColorService\" }, \"retryPolicy\" : { \"grpcRetryEvents\" : [ \"deadline-exceeded\" ], \"httpRetryEvents\" : [ \"server-error\", \"gateway-error\" ], \"maxRetries\" : 3, \"perRetryTimeout\" : { \"unit\" : \"s\", \"value\" : 15 }, \"tcpRetryEvents\" : [ \"connection-error\" ] } }, \"priority\" : 100 }, \"virtualRouterName\" : \"serviceBgrpc\" } 출력: { \"route\": { \"meshName\": \"apps\", \"metadata\": { \"arn\": \"arn:aws:appmesh:us-west-2:123456789012:mesh/apps/virtualRouter/ serviceBgrpc/route/grpcRoute\", \"createdAt\": 1572010806.008, \"lastUpdatedAt\": 1572010806.008, \"uid\": \"a1b2c3d4-5678-90ab-cdef-11111EXAMPLE\", \"version\": 1 }, \"routeName\": \"grpcRoute\", \"spec\": { \"grpcRoute\": { \"action\": { App Mesh 519\n\n AWS Command Line Interface 버전 2 사용 설명서 \"weightedTargets\": [ { \"virtualNode\": \"serviceBgrpc\", \"weight\": 100 } ] }, \"match\": { \"metadata\": [ { \"invert\": false, \"match\": { \"prefix\": \"123\" }, \"name\": \"mymetadata\" } ], \"methodName\": \"GetColor\", \"serviceName\": \"com.amazonaws.services.ColorService\" }, \"retryPolicy\": { \"grpcRetryEvents\": [ \"deadline-exceeded\" ], \"httpRetryEvents\": [ \"server-error\", \"gateway-error\" ], \"maxRetries\": 3, \"perRetryTimeout\": { \"unit\": \"s\", \"value\": 15 }, \"tcpRetryEvents\": [ \"connection-error\" ] } }, \"priority\": 100 }, \"status\": { \"status\": \"ACTIVE\" }, \"virtualRouterName\": \"serviceBgrpc\" App Mesh 520\n\n AWS Command Line Interface 버전 2 사용 설명서 } } 새 HTTP 또는 HTTP/2 경로를 생성하는 방법 다음 create-route 예제에서는 JSON 입력 파일을 사용하여 HTTP/2 경로를 생성합니다. HTTP 경로를 생성하려면 http2Route를 사양에 따라 httpRoute로 바꿉니다. 헤더 값이 123으로 시작하는 URL 접두사로 주소 지정된 모든 HTTP/2 트래픽이 serviceBhttp2라는 이름의 가상 노드로 라우팅 됩니다. 이 경로의 대상과 통신을 시도할 때 특정 HTTP 또는 TCP 실패가 발생하는 경우 경로가 3 회 재시도됩니다. 각 재시도 사이에 15초의 지연이 발생합니다. aws appmesh create-route \\ --cli-input-json file://create-route-http2.json create-route-http2.json의 콘텐츠: { \"meshName\": \"apps\", \"routeName\": \"http2Route\", \"spec\": { \"http2Route\": { \"action\": { \"weightedTargets\": [ { \"virtualNode\": \"serviceBhttp2\", \"weight\": 100 } ] }, \"match\": { \"headers\": [ { \"invert\": false, \"match\": { \"prefix\": \"123\" }, \"name\": \"clientRequestId\" } ], \"method\": \"POST\", \"prefix\": \"/\", \"scheme\": \"http\" App Mesh 521\n\n AWS Command Line Interface }, 버전 2 사용 설명서 \"retryPolicy\": { \"httpRetryEvents\": [ \"server-error\", \"gateway-error\" ], \"maxRetries\": 3, \"perRetryTimeout\": { \"unit\": \"s\", \"value\": 15 }, \"tcpRetryEvents\": [ \"connection-error\" ] } }, \"priority\": 200 }, \"virtualRouterName\": \"serviceBhttp2\" } 출력: { \"route\": { \"meshName\": \"apps\", \"metadata\": { \"arn\": \"arn:aws:appmesh:us-west-2:123456789012:mesh/apps/virtualRouter/ serviceBhttp2/route/http2Route\", \"createdAt\": 1572011008.352, \"lastUpdatedAt\": 1572011008.352, \"uid\": \"a1b2c3d4-5678-90ab-cdef-11111EXAMPLE\", \"version\": 1 }, \"routeName\": \"http2Route\", \"spec\": { \"http2Route\": { \"action\": { \"weightedTargets\": [ { \"virtualNode\": \"serviceBhttp2\", \"weight\": 100 } App Mesh 522\n\n AWS Command Line Interface 버전 2 사용 설명서 ] }, \"match\": { \"headers\": [ { \"invert\": false, \"match\": { \"prefix\": \"123\" }, \"name\": \"clientRequestId\" } ], \"method\": \"POST\", \"prefix\": \"/\", \"scheme\": \"http\" }, \"retryPolicy\": { \"httpRetryEvents\": [ \"server-error\", \"gateway-error\" ], \"maxRetries\": 3, \"perRetryTimeout\": { \"unit\": \"s\", \"value\": 15 }, \"tcpRetryEvents\": [ \"connection-error\" ] } }, \"priority\": 200 }, \"status\": { \"status\": \"ACTIVE\" }, \"virtualRouterName\": \"serviceBhttp2\" } } 새 TCP 경로를 생성하는 방법 App Mesh 523\n\n AWS Command Line Interface 버전 2 사용 설명서 다음 create-route 예제에서는 JSON 입력 파일을 사용하여 TCP 경로를 생성합니다. 트래픽의 75%는 serviceBtcp라는 이름의 가상 노드로 라우팅되고 트래픽의 25%는 serviceBv2tcp라는 이름 의 가상 노드로 라우팅됩니다. 다양한 대상에 대해 다양한 가중치를 지정하는 것은 애플리케이션의 새 버전을 배포하는 효과적인 방법입니다. 최종적으로 모든 트래픽의 100%가 애플리케이션의 새 버전이 있는 대상으로 라우팅되도록 가중치를 조정할 수 있습니다. aws appmesh create-route \\ --cli-input-json file://create-route-tcp.json create-route-tcp.json의 콘텐츠: { \"meshName\": \"apps\", \"routeName\": \"tcpRoute\", \"spec\": { \"priority\": 300, \"tcpRoute\": { \"action\": { \"weightedTargets\": [ { \"virtualNode\": \"serviceBtcp\", \"weight\": 75 }, { \"virtualNode\": \"serviceBv2tcp\", \"weight\": 25 } ] } } }, \"virtualRouterName\": \"serviceBtcp\" } 출력: { \"route\": { \"meshName\": \"apps\", \"metadata\": { \"arn\": \"arn:aws:appmesh:us-west-2:123456789012:mesh/apps/virtualRouter/ serviceBtcp/route/tcpRoute\", App Mesh 524\n\n AWS Command Line Interface 버전 2 사용 설명서 \"createdAt\": 1572011436.26, \"lastUpdatedAt\": 1572011436.26, \"uid\": \"a1b2c3d4-5678-90ab-cdef-11111EXAMPLE\", \"version\": 1 }, \"routeName\": \"tcpRoute\", \"spec\": { \"priority\": 300, \"tcpRoute\": { \"action\": { \"weightedTargets\": [ { \"virtualNode\": \"serviceBtcp\", \"weight\": 75 }, { \"virtualNode\": \"serviceBv2tcp\", \"weight\": 25 } ] } } }, \"status\": { \"status\": \"ACTIVE\" }, \"virtualRouterName\": \"serviceBtcp\" } } 자세한 내용은 AWS App Mesh 사용 설명서의 라우팅을 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 CreateRoute를 참조하세요. create-virtual-gateway 다음 코드 예시는 create-virtual-gateway의 사용 방법을 보여 줍니다. AWS CLI 새 가상 게이트웨이를 생성하는 방법 App Mesh 525\n\n AWS Command\n\n--cli-input-json file://create-route-tcp.json create-route-tcp.json의 콘텐츠: { \"meshName\": \"apps\", \"routeName\": \"tcpRoute\", \"spec\": { \"priority\": 300, \"tcpRoute\": { \"action\": { \"weightedTargets\": [ { \"virtualNode\": \"serviceBtcp\", \"weight\": 75 }, { \"virtualNode\": \"serviceBv2tcp\", \"weight\": 25 } ] } } }, \"virtualRouterName\": \"serviceBtcp\" } 출력: { \"route\": { \"meshName\": \"apps\", \"metadata\": { \"arn\": \"arn:aws:appmesh:us-west-2:123456789012:mesh/apps/virtualRouter/ serviceBtcp/route/tcpRoute\", App Mesh 524\n\n AWS Command Line Interface 버전 2 사용 설명서 \"createdAt\": 1572011436.26, \"lastUpdatedAt\": 1572011436.26, \"uid\": \"a1b2c3d4-5678-90ab-cdef-11111EXAMPLE\", \"version\": 1 }, \"routeName\": \"tcpRoute\", \"spec\": { \"priority\": 300, \"tcpRoute\": { \"action\": { \"weightedTargets\": [ { \"virtualNode\": \"serviceBtcp\", \"weight\": 75 }, { \"virtualNode\": \"serviceBv2tcp\", \"weight\": 25 } ] } } }, \"status\": { \"status\": \"ACTIVE\" }, \"virtualRouterName\": \"serviceBtcp\" } } 자세한 내용은 AWS App Mesh 사용 설명서의 라우팅을 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 CreateRoute를 참조하세요. create-virtual-gateway 다음 코드 예시는 create-virtual-gateway의 사용 방법을 보여 줍니다. AWS CLI 새 가상 게이트웨이를 생성하는 방법 App Mesh 525\n\n AWS Command Line Interface 버전 2 사용 설명서 다음 create-virtual-gateway 예제에서는 JSON 입력 파일을 사용하여, 포트 9080을 사용하 는 HTTP에 대한 리스너가 있는 가상 게이트웨이를 생성합니다. aws appmesh create-virtual-gateway \\ --mesh-name meshName \\ --virtual-gateway-name virtualGatewayName \\ --cli-input-json file://create-virtual-gateway.json create-virtual-gateway.json의 콘텐츠: { \"spec\": { \"listeners\": [ { \"portMapping\": { \"port\": 9080, \"protocol\": \"http\" } } ] } } 출력: { \"virtualGateway\": { \"meshName\": \"meshName\", \"metadata\": { \"arn\": \"arn:aws:appmesh:us-west-2:123456789012:mesh/meshName/ virtualGateway/virtualGatewayName\", \"createdAt\": \"2022-04-06T10:42:42.015000-05:00\", \"lastUpdatedAt\": \"2022-04-06T10:42:42.015000-05:00\", \"meshOwner\": \"123456789012\", \"resourceOwner\": \"123456789012\", \"uid\": \"a1b2c3d4-5678-90ab-cdef-11111EXAMPLE\", \"version\": 1 }, \"spec\": { \"listeners\": [ { \"portMapping\": { App Mesh 526\n\n AWS Command Line Interface 버전 2 사용 설명서 \"port\": 9080, \"protocol\": \"http\" } } ] }, \"status\": { \"status\": \"ACTIVE\" }, \"virtualGatewayName\": \"virtualGatewayName\" } } 자세한 내용은 AWS App Mesh 사용 설명서의 가상 게이트웨이를 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 CreateVirtualGateway를 참조하세요. create-virtual-node 다음 코드 예시는 create-virtual-node의 사용 방법을 보여 줍니다. AWS CLI 예제 1: 검색에 DNS를 사용하는 새 가상 노드를 생성하는 방법 다음 create-virtual-node 예제에서는 JSON 입력 파일을 사용하여, 서비스 검색에 DNS를 사 용하는 가상 노드를 생성합니다. aws appmesh create-virtual-node \\ --cli-input-json file://create-virtual-node-dns.json create-virtual-node-dns.json의 콘텐츠: { \"meshName\": \"app1\", \"spec\": { \"listeners\": [ { \"portMapping\": { \"port\": 80, \"protocol\": \"http\" } App Mesh 527\n\n AWS Command Line Interface } ], \"serviceDiscovery\": { \"dns\": { \"hostname\": \"serviceBv1.svc.cluster.local\" } } }, \"virtualNodeName\": \"vnServiceBv1\" 버전 2 사용 설명서 } 출력: { \"virtualNode\": { \"meshName\": \"app1\", \"metadata\": { \"arn\": \"arn:aws:appmesh:us-east-1:123456789012:mesh/app1/virtualNode/ vnServiceBv1\", \"createdAt\": 1563810019.874, \"lastUpdatedAt\": 1563810019.874, \"uid\": \"a1b2c3d4-5678-90ab-cdef-11111EXAMPLE\", \"version\": 1 }, \"spec\": { \"listeners\": [ { \"portMapping\": { \"port\": 80, \"protocol\": \"http\" } } ], \"serviceDiscovery\": { \"dns\": { \"hostname\": \"serviceBv1.svc.cluster.local\" } } }, \"status\": { \"status\": \"ACTIVE\" }, \"virtualNodeName\": \"vnServiceBv1\" App Mesh 528\n\n AWS Command Line Interface 버전 2 사용 설명서 } } 예제 2: 검색에 AWS Cloud Map을 사용하는 새 가상 노드를 생성하는 방법 다음 create-virtual-node 예제에서는 JSON 입력 파일을 사용하여, 서비스 검색에 AWS Cloud Map을 사용하는 가상 노드를 생성합니다. aws appmesh create-virtual-node \\ --cli-input-json file://create-virtual-node-cloud-map.json create-virtual-node-cloud-map.json의 콘텐츠: { \"meshName\": \"app1\", \"spec\": { \"backends\": [ { \"virtualService\": { \"virtualServiceName\": \"serviceA.svc.cluster.local\" } } ], \"listeners\": [ { \"portMapping\": { \"port\": 80, \"protocol\": \"http\" } } ], \"serviceDiscovery\": { \"awsCloudMap\": { \"attributes\": [ { \"key\": \"Environment\", \"value\": \"Testing\" } ], \"namespaceName\": \"namespace1\", \"serviceName\": \"serviceA\" } } App Mesh 529\n\n 버전 2 사용 설명서 AWS Command Line Interface }, \"virtualNodeName\": \"vnServiceA\" } 출력: { \"virtualNode\": { \"meshName\": \"app1\", \"metadata\": { \"arn\": \"arn:aws:appmesh:us-east-1:123456789012:mesh/app1/virtualNode/ vnServiceA\", \"createdAt\": 1563810859.465, \"lastUpdatedAt\": 1563810859.465, \"uid\": \"a1b2c3d4-5678-90ab-cdef-11111EXAMPLE\", \"version\": 1 }, \"spec\": { \"backends\": [ { \"virtualService\": { \"virtualServiceName\": \"serviceA.svc.cluster.local\" } } ], \"listeners\": [ { \"portMapping\": { \"port\": 80, \"protocol\": \"http\" } } ], \"serviceDiscovery\": { \"awsCloudMap\": { \"attributes\": [ { \"key\": \"Environment\", \"value\": \"Testing\" } ], \"namespaceName\": \"namespace1\", \"serviceName\": \"serviceA\" App Mesh 530\n\n AWS Command Line Interface 버전 2 사용 설명서 } } }, \"status\": { \"status\": \"ACTIVE\" }, \"virtualNodeName\": \"vnServiceA\" } } 자세한 내용은 AWS App Mesh 사용 설명서의 가상 노드를 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 CreateVirtualNode를 참조하세요. create-virtual-router 다음 코드 예시는 create-virtual-router의 사용 방법을 보여 줍니다. AWS CLI 새 가상 라우터를 생성하는 방법 다음 create-virtual-router 예제에서는 JSON 입력 파일을 사용하여, 포트 80을 사용하는 HTTP에 대한 리스너가 있는 가상 라우터를 생성합니다. aws appmesh create-virtual-router \\ --cli-input-json file://create-virtual-router.json create-virtual-router.json의 콘텐츠: { \"meshName\": \"app1\", \"spec\": { \"listeners\": [ { \"portMapping\": { \"port\": 80, \"protocol\": \"http\" } } ] }, \"virtualRouterName\": \"vrServiceB\" App Mesh 531\n\n AWS Command Line Interface 버전 2 사용 설명서 } 출력: { \"virtualRouter\": { \"meshName\": \"app1\", \"metadata\": { \"arn\": \"arn:aws:appmesh:us-east-1:123456789012:mesh/app1/virtualRouter/ vrServiceB\", \"createdAt\": 1563810546.59, \"lastUpdatedAt\": 1563810546.59, \"uid\": \"a1b2c3d4-5678-90ab-cdef-11111EXAMPLE\", \"version\": 1 }, \"spec\": { \"listeners\": [ { \"portMapping\": { \"port\": 80, \"protocol\": \"http\" } } ] }, \"status\": { \"status\": \"ACTIVE\" }, \"virtualRouterName\": \"vrServiceB\" } } 자세한 내용은 AWS App Mesh 사용 설명서의 가상 라우터를 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 CreateVirtualRouter를 참조하세요. create-virtual-service 다음 코드 예시는 create-virtual-service의 사용 방법을 보여 줍니다. AWS CLI 예제 1: 가상 노드 공급자가 있는 새 가상 서비스를 생성하는 방법 App Mesh 532\n\n AWS Command Line Interface 버전 2 사용 설명서 다음 create-virtual-service 예제에서는 JSON 입력 파일을 사용하여 가상 노드 공급자가 있는 가상 서비스를 생성합니다. aws appmesh create-virtual-service \\ --cli-input-json file://create-virtual-service-virtual-node.json create-virtual-service-virtual-node.json의 콘텐츠: { \"meshName\": \"app1\", \"spec\": { \"provider\": { \"virtualNode\": { \"virtualNodeName\": \"vnServiceA\" } } }, \"virtualServiceName\": \"serviceA.svc.cluster.local\" } 출력: { \"virtualService\": { \"meshName\": \"app1\", \"metadata\": { \"arn\": \"arn:aws:appmesh:us-east-1:123456789012:mesh/app1/virtualService/ serviceA.svc.cluster.local\", \"createdAt\": 1563810859.474, \"lastUpdatedAt\": 1563810967.179, \"uid\": \"a1b2c3d4-5678-90ab-cdef-11111EXAMPLE\", \"version\": 2 }, \"spec\": { \"provider\": { \"virtualNode\": { \"virtualNodeName\": \"vnServiceA\" } } }, \"status\": { \"status\": \"ACTIVE\" App Mesh 533\n\n AWS Command Line Interface },\n\n] }, \"status\": { \"status\": \"ACTIVE\" }, \"virtualRouterName\": \"vrServiceB\" } } 자세한 내용은 AWS App Mesh 사용 설명서의 가상 라우터를 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 CreateVirtualRouter를 참조하세요. create-virtual-service 다음 코드 예시는 create-virtual-service의 사용 방법을 보여 줍니다. AWS CLI 예제 1: 가상 노드 공급자가 있는 새 가상 서비스를 생성하는 방법 App Mesh 532\n\n AWS Command Line Interface 버전 2 사용 설명서 다음 create-virtual-service 예제에서는 JSON 입력 파일을 사용하여 가상 노드 공급자가 있는 가상 서비스를 생성합니다. aws appmesh create-virtual-service \\ --cli-input-json file://create-virtual-service-virtual-node.json create-virtual-service-virtual-node.json의 콘텐츠: { \"meshName\": \"app1\", \"spec\": { \"provider\": { \"virtualNode\": { \"virtualNodeName\": \"vnServiceA\" } } }, \"virtualServiceName\": \"serviceA.svc.cluster.local\" } 출력: { \"virtualService\": { \"meshName\": \"app1\", \"metadata\": { \"arn\": \"arn:aws:appmesh:us-east-1:123456789012:mesh/app1/virtualService/ serviceA.svc.cluster.local\", \"createdAt\": 1563810859.474, \"lastUpdatedAt\": 1563810967.179, \"uid\": \"a1b2c3d4-5678-90ab-cdef-11111EXAMPLE\", \"version\": 2 }, \"spec\": { \"provider\": { \"virtualNode\": { \"virtualNodeName\": \"vnServiceA\" } } }, \"status\": { \"status\": \"ACTIVE\" App Mesh 533\n\n AWS Command Line Interface }, \"virtualServiceName\": \"serviceA.svc.cluster.local\" } } 자세한 내용은 AWS App Mesh 사용 설명서의 가상 노드를 참조하세요. 예제 2: 가상 라우터 공급자가 있는 새 가상 서비스를 생성하는 방법 버전 2 사용 설명서 다음 create-virtual-service 예제에서는 JSON 입력 파일을 사용하여 가상 라우터 공급자가 있는 가상 서비스를 생성합니다. aws appmesh create-virtual-service \\ --cli-input-json file://create-virtual-service-virtual-router.json create-virtual-service-virtual-router.json의 콘텐츠: { \"meshName\": \"app1\", \"spec\": { \"provider\": { \"virtualRouter\": { \"virtualRouterName\": \"vrServiceB\" } } }, \"virtualServiceName\": \"serviceB.svc.cluster.local\" } 출력: { \"virtualService\": { \"meshName\": \"app1\", \"metadata\": { \"arn\": \"arn:aws:appmesh:us-east-1:123456789012:mesh/app1/virtualService/ serviceB.svc.cluster.local\", \"createdAt\": 1563908363.999, \"lastUpdatedAt\": 1563908363.999, \"uid\": \"a1b2c3d4-5678-90ab-cdef-11111EXAMPLE\", \"version\": 1 }, App Mesh 534\n\n AWS Command Line Interface 버전 2 사용 설명서 \"spec\": { \"provider\": { \"virtualRouter\": { \"virtualRouterName\": \"vrServiceB\" } } }, \"status\": { \"status\": \"ACTIVE\" }, \"virtualServiceName\": \"serviceB.svc.cluster.local\" } } 자세한 내용은 AWS App Mesh 사용 설명서의 가상 서비스<https://docs.aws.amazon.com/app- mesh/latest/userguide/virtual_services.html>를 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 CreateVirtualService를 참조하세요. delete-mesh 다음 코드 예시는 delete-mesh의 사용 방법을 보여 줍니다. AWS CLI 서비스 메시를 삭제하는 방법 다음 delete-mesh 예제에서는 지정된 서비스 메시를 삭제합니다. aws appmesh delete-mesh \\ --mesh-name app1 출력: { \"mesh\": { \"meshName\": \"app1\", \"metadata\": { \"arn\": \"arn:aws:appmesh:us-east-1:123456789012:mesh/app1\", \"createdAt\": 1563809909.282, \"lastUpdatedAt\": 1563824981.248, \"uid\": \"a1b2c3d4-5678-90ab-cdef-11111EXAMPLE\", App Mesh 535\n\n AWS Command Line Interface 버전 2 사용 설명서 \"version\": 2 }, \"spec\": { \"egressFilter\": { \"type\": \"ALLOW_ALL\" } }, \"status\": { \"status\": \"DELETED\" } } } 자세한 내용은 AWS App Mesh 사용 설명서의 서비스 메시를 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 DeleteMesh를 참조하세요. delete-route 다음 코드 예시는 delete-route의 사용 방법을 보여 줍니다. AWS CLI 경로를 삭제하는 방법 다음 delete-route 예제에서는 지정된 경로를 삭제합니다. aws appmesh delete-route \\ --mesh-name app1 \\ --virtual-router-name vrServiceB \\ --route-name toVnServiceB-weighted 출력: { \"route\": { \"meshName\": \"app1\", \"metadata\": { \"arn\": \"arn:aws:appmesh:us-east-1:123456789012:mesh/app1/virtualRouter/ vrServiceB/route/toVnServiceB-weighted\", \"createdAt\": 1563811384.015, \"lastUpdatedAt\": 1563823915.936, App Mesh 536\n\n AWS Command Line Interface 버전 2 사용 설명서 \"uid\": \"a1b2c3d4-5678-90ab-cdef-11111EXAMPLE\", \"version\": 3 }, \"routeName\": \"toVnServiceB-weighted\", \"spec\": { \"httpRoute\": { \"action\": { \"weightedTargets\": [ { \"virtualNode\": \"vnServiceBv1\", \"weight\": 80 }, { \"virtualNode\": \"vnServiceBv2\", \"weight\": 20 } ] }, \"match\": { \"prefix\": \"/\" } } }, \"status\": { \"status\": \"DELETED\" }, \"virtualRouterName\": \"vrServiceB\" } } 자세한 내용은 AWS App Mesh 사용 설명서의 라우팅을 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 DeleteRoute를 참조하세요. delete-virtual-node 다음 코드 예시는 delete-virtual-node의 사용 방법을 보여 줍니다. AWS CLI 가상 노드를 삭제하는 방법 다음 delete-virtual-node 예제에서는 지정된 가상 노드를 삭제합니다. App Mesh 537\n\n AWS Command Line Interface 버전 2 사용 설명서 aws appmesh delete-virtual-node \\ --mesh-name app1 \\ --virtual-node-name vnServiceBv2 출력: { \"virtualNode\": { \"meshName\": \"app1\", \"metadata\": { \"arn\": \"arn:aws:appmesh:us-east-1:123456789012:mesh/app1/virtualNode/ vnServiceBv2\", \"createdAt\": 1563810117.297, \"lastUpdatedAt\": 1563824700.678, \"uid\": \"a1b2c3d4-5678-90ab-cdef-11111EXAMPLE\", \"version\": 2 }, \"spec\": { \"backends\": [], \"listeners\": [ { \"portMapping\": { \"port\": 80, \"protocol\": \"http\" } } ], \"serviceDiscovery\": { \"dns\": { \"hostname\": \"serviceBv2.svc.cluster.local\" } } }, \"status\": { \"status\": \"DELETED\" }, \"virtualNodeName\": \"vnServiceBv2\" } } 자세한 내용은 AWS App Mesh 사용 설명서의 가상 노드를 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 DeleteVirtualNode를 참조하세요. App Mesh 538\n\n AWS Command Line Interface delete-virtual-router 버전 2 사용 설명서 다음 코드 예시는 delete-virtual-router의 사용 방법을 보여 줍니다. AWS CLI 가상 라우터를 삭제하는 방법 다음 delete-virtual-router 예제에서는 지정된 가상 라우터를 삭제합니다. aws appmesh delete-virtual-router \\ --mesh-name app1 \\ --virtual-router-name vrServiceB 출력: { \"virtualRouter\": { \"meshName\": \"app1\", \"metadata\": { \"arn\": \"arn:aws:appmesh:us-east-1:123456789012:mesh/app1/virtualRouter/ vrServiceB\", \"createdAt\": 1563810546.59, \"lastUpdatedAt\": 1563824253.467, \"uid\": \"a1b2c3d4-5678-90ab-cdef-11111EXAMPLE\", \"version\": 3 }, \"spec\": { \"listeners\": [ { \"portMapping\": { \"port\": 80, \"protocol\": \"http\" } } ] }, \"status\": { \"status\": \"DELETED\" }, \"virtualRouterName\": \"vrServiceB\" } } App Mesh 539\n\n AWS Command Line Interface 버전 2 사용 설명서 자세한 내용은 AWS App Mesh 사용 설명서의 가상 라우터를 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 DeleteVirtualRouter를 참조하세요. delete-virtual-service 다음 코드 예시는 delete-virtual-service의 사용 방법을 보여 줍니다. AWS CLI 가상 서비스를 삭제하는 방법 다음 delete-virtual-service 예제에서는 지정된 가상 서비스를 삭제합니다. aws appmesh delete-virtual-service \\ --mesh-name app1 \\ --virtual-service-name serviceB.svc.cluster.local 출력: { \"virtualService\": { \"meshName\": \"app1\", \"metadata\": { \"arn\": \"arn:aws:appmesh:us-east-1:123456789012:mesh/app1/virtualService/ serviceB.svc.cluster.local\", \"createdAt\": 1563908363.999, \"lastUpdatedAt\": 1563913940.866, \"uid\": \"a1b2c3d4-5678-90ab-cdef-11111EXAMPLE\", \"version\": 3 }, \"spec\": {}, \"status\": { \"status\": \"DELETED\" }, \"virtualServiceName\": \"serviceB.svc.cluster.local\" } } 자세한 내용은 AWS App Mesh 사용 설명서의 가상 서비스를 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 DeleteVirtualService를 참조하세요. App Mesh 540\n\n AWS Command Line Interface describe-mesh 다음 코드 예시는 describe-mesh의 사용 방법을 보여 줍니다. AWS CLI 서비스 메시를 설명하는 방법 버전 2 사용 설명서 다음 describe-mesh 예제에서는 지정된 서비스 메시에 대한 세부 정보를 반환합니다. aws appmesh describe-mesh \\ --mesh-name app1 출력: { \"mesh\": { \"meshName\": \"app1\", \"metadata\": { \"arn\": \"arn:aws:appmesh:us-east-1:123456789012:mesh/app1\", \"createdAt\": 1563809909.282, \"lastUpdatedAt\": 1563809909.282, \"uid\": \"a1b2c3d4-5678-90ab-cdef-11111EXAMPLE\", \"version\": 1 }, \"spec\": {}, \"status\": { \"status\":"}, {"ref": "/docs/ec2-dg.pdf", "chunk_id": "aws/ec2-dg_pdf#chunk109", "doc_id": "aws/ec2-dg_pdf", "page": 565, "anchor": "찾고 설정 및 실행하는 방법을 배워보세요. 작업 555\n\n Amazon Elastic Compute Cloud 개발자 안내서 class VpcWrapper: \"\"\"Encapsulates Amazon Elastic Compute Cloud (Amazon EC2) Amazon Virtual Private Cloud actions.\"\"\" def __init__(self, ec2_client: boto3.client): \"\"\" Initializes the VpcWrapper with an EC2 client. :param ec2_client: A Boto3 Amazon EC2 client. This client provides low- level access to AWS EC2 services. \"\"\" self.ec2_client = ec2_client @classmethod def from_client(cls) -> \"VpcWrapper\": \"\"\" Creates a VpcWrapper instance with a default EC2 client. :return: An instance of VpcWrapper initialized with the default EC2 client. \"\"\" ec2_client = boto3.client(\"ec2\") return cls(ec2_client) def create(self, cidr_block: str) -> str: \"\"\" Creates a new Amazon VPC with the specified CIDR block. :param cidr_block: The CIDR block for the new VPC, such as '10.0.0.0/16'. :return: The ID of the new VPC. \"\"\" try: response = self.ec2_client.create_vpc(CidrBlock=cidr_block) vpc_id = response[\"Vpc\"][\"VpcId\"] waiter = self.ec2_client.get_waiter(\"vpc_available\") waiter.wait(VpcIds=[vpc_id]) return vpc_id except ClientError as client_error: logging.error( \"Couldn't create the vpc. Here's why: %s\", 작업 556\n\n Amazon Elastic Compute Cloud 개발자 안내서 client_error.response[\"Error\"][\"Message\"], ) raise • API 세부 정보는 SDK for Python (Boto3) API 참조의 CreateVpc를 참조하세요. AWS Ruby SDK for Ruby Note GitHub에 더 많은 내용이 있습니다. AWS 코드 예제 리포지토리에서 전체 예제를 찾고 설정 및 실행하는 방법을 배워보세요. require 'aws-sdk-ec2' # Creates a virtual private cloud (VPC) in # Amazon Virtual Private Cloud (Amazon VPC) and then tags # the VPC. # # @param ec2_resource [Aws::EC2::Resource] An initialized # Amazon Elastic Compute Cloud (Amazon EC2) resource object. # @param cidr_block [String] The IPv4 CIDR block for the subnet. # @param tag_key [String] The key portion of the tag for the VPC. # @param tag_value [String] The value portion of the tag for the VPC. # @return [Boolean] true if the VPC was created and tagged; # otherwise, false. # @example # exit 1 unless vpc_created_and_tagged?( # Aws::EC2::Resource.new(region: 'us-west-2'), # '10.0.0.0/24', # 'my-key', # 'my-value' # ) def vpc_created_and_tagged?( ec2_resource, cidr_block, 작업 557\n\n Amazon Elastic Compute Cloud 개발자 안내서 tag_key, tag_value ) vpc = ec2_resource.create_vpc(cidr_block: cidr_block) # Create a public DNS by enabling DNS support and DNS hostnames. vpc.modify_attribute(enable_dns_support: { value: true }) vpc.modify_attribute(enable_dns_hostnames: { value: true }) vpc.create_tags(tags: [{ key: tag_key, value: tag_value }]) puts \"Created VPC with ID '#{vpc.id}' and tagged with key \" \\ \"'#{tag_key}' and value '#{tag_value}'.\" true rescue StandardError => e puts e.message false end # Example usage: def run_me cidr_block = '' tag_key = '' tag_value = '' region = '' # Print usage information and then stop. if ARGV[0] == '--help' || ARGV[0] == '-h' puts 'Usage: ruby ec2-ruby-example-create-vpc.rb ' \\ 'CIDR_BLOCK TAG_KEY TAG_VALUE REGION' # Replace us-west-2 with the AWS Region you're using for Amazon EC2. puts 'Example: ruby ec2-ruby-example-create-vpc.rb ' \\ '10.0.0.0/24 my-key my-value us-west-2' exit 1 # If no values are specified at the command prompt, use these default values. elsif ARGV.count.zero? cidr_block = '10.0.0.0/24' tag_key = 'my-key' tag_value = 'my-value' # Replace us-west-2 with the AWS Region you're using for Amazon EC2. region = 'us-west-2' # Otherwise, use the values as specified at the command prompt. else cidr_block = ARGV[0] tag_key = ARGV[1] 작업 558\n\n Amazon Elastic Compute Cloud 개발자 안내서 tag_value = ARGV[2] region = ARGV[3] end ec2_resource = Aws::EC2::Resource.new(region: region) if vpc_created_and_tagged?( ec2_resource, cidr_block, tag_key, tag_value ) puts 'VPC created and tagged.' else puts 'VPC not created or not tagged.' end end run_me if $PROGRAM_NAME == __FILE__ • API 세부 정보는 AWS SDK for Ruby API 참조의 CreateVpc를 참조하십시오. AWS SDK 개발자 안내서 및 코드 예제의 전체 목록은 섹션을 참조하세요AWS SDK를 사용하여 Amazon EC2 리소스 생성. 이 주제에는 시작하기에 대한 정보와 이전 SDK 버전에 대한 세부 정보도 포함되어 있습니다. AWS SDK 또는 CLI와 CreateVpcEndpoint 함께 사용 다음 코드 예시는 CreateVpcEndpoint의 사용 방법을 보여 줍니다. 작업 예제는 대규모 프로그램에서 발췌한 코드이며 컨텍스트에 맞춰 실행해야 합니다. 다음 코드 예제 에서는 컨텍스트 내에서 이 작업을 확인할 수 있습니다. • 프라이빗 서브넷과 NAT 게이트웨이가 포함된 VPC 생성 CLI AWS CLI 예시 1: 게이트웨이 엔드포인트 생성 작업 559\n\n Amazon Elastic Compute Cloud 개발자 안내서 다음 create-vpc-endpoint 예시에서는 VPC vpc-1a2b3c4d와 us-east-1 리전의 Amazon S3 사이에 게이트웨이 VPC 엔드포인트를 생성하고 라우팅 테이블 rtb-11aa22bb를 엔드포인트와 연결합니다. aws ec2 create-vpc-endpoint \\ --vpc-id vpc-1a2b3c4d \\ --service-name com.amazonaws.us-east-1.s3 \\ --route-table-ids rtb-11aa22bb 출력: { \"VpcEndpoint\": { \"PolicyDocument\": \"{\\\"Version\\\":\\\"2008-10-17\\\",\\\"Statement\\\":[{\\\"Sid\\\": \\\"\\\",\\\"Effect\\\":\\\"Allow\\\",\\\"Principal\\\":\\\"\\*\\\",\\\"Action\\\":\\\"\\*\\\",\\\"Resource\\\": \\\"\\*\\\"}]}\", \"VpcId\": \"vpc-1a2b3c4d\", \"State\": \"available\", \"ServiceName\": \"com.amazonaws.us-east-1.s3\", \"RouteTableIds\": [ \"rtb-11aa22bb\" ], \"VpcEndpointId\": \"vpc-1a2b3c4d\", \"CreationTimestamp\": \"2015-05-15T09:40:50Z\" } } 자세한 내용은 AWS PrivateLink 설명서의 게이트웨이 엔드포인트 생성을 참조하세요. 예시 2: 인터페이스 엔드포인트 생성 다음 create-vpc-endpoint 예시에서는 us-east-1 리전의 VPC vpc-1a2b3c4d와 Amazon S3 사이에 인터페이스 VPC 엔드포인트를 생성합니다. 이 명령은 subnet-1a2b3c4d 서브넷에 엔드포인트를 만들고 sg-1a2b3c4d 보안 그룹에 연결한 다음 키가 'Service'이고 값 이 'S3'인 태그를 추가합니다. aws ec2 create-vpc-endpoint \\ --vpc-id vpc-1a2b3c4d \\ --vpc-endpoint-type Interface \\ --service-name com.amazonaws.us-east-1.s3 \\ --subnet-ids subnet-7b16de0c \\ 작업 560\n\n Amazon Elastic Compute Cloud 개발자 안내서 --security-group-id sg-1a2b3c4d \\ --tag-specifications ResourceType=vpc-endpoint,Tags=[{Key=service,Value=S3}] 출력: { \"VpcEndpoint\": { \"VpcEndpointId\": \"vpce-1a2b3c4d5e6f1a2b3\", \"VpcEndpointType\": \"Interface\", \"VpcId\": \"vpc-1a2b3c4d\", \"ServiceName\": \"com.amazonaws.us-east-1.s3\", \"State\": \"pending\", \"RouteTableIds\": [], \"SubnetIds\": [ \"subnet-1a2b3c4d\" ], \"Groups\": [ { \"GroupId\": \"sg-1a2b3c4d\", \"GroupName\": \"default\" } ], \"PrivateDnsEnabled\": false, \"RequesterManaged\": false, \"NetworkInterfaceIds\": [ \"eni-0b16f0581c8ac6877\" ], \"DnsEntries\": [ { \"DnsName\": \"*.vpce-1a2b3c4d5e6f1a2b3-9hnenorg.s3.us- east-1.vpce.amazonaws.com\", \"HostedZoneId\": \"Z7HUB22UULQXV\" }, { \"DnsName\": \"*.vpce-1a2b3c4d5e6f1a2b3-9hnenorg-us-east-1c.s3.us- east-1.vpce.amazonaws.com\", \"HostedZoneId\": \"Z7HUB22UULQXV\" } ], \"CreationTimestamp\": \"2021-03-05T14:46:16.030000+00:00\", \"Tags\": [ { \"Key\": \"service\", 작업 561\n\n Amazon Elastic Compute Cloud 개발자 안내서 \"Value\": \"S3\" } ], \"OwnerId\": \"123456789012\" } } 자세한 내용은 AWS PrivateLink 사용 설명서의 인터페이스 VPC 엔드포인트 생성을 참조하세 요. 예시 3: Gateway Load Balancer 엔드포인트 생성 다음 create-vpc-endpoint 예시에서는 VPC vpc-111122223333aabbc와 Gateway\n\n서브넷에 엔드포인트를 만들고 sg-1a2b3c4d 보안 그룹에 연결한 다음 키가 'Service'이고 값 이 'S3'인 태그를 추가합니다. aws ec2 create-vpc-endpoint \\ --vpc-id vpc-1a2b3c4d \\ --vpc-endpoint-type Interface \\ --service-name com.amazonaws.us-east-1.s3 \\ --subnet-ids subnet-7b16de0c \\ 작업 560\n\n Amazon Elastic Compute Cloud 개발자 안내서 --security-group-id sg-1a2b3c4d \\ --tag-specifications ResourceType=vpc-endpoint,Tags=[{Key=service,Value=S3}] 출력: { \"VpcEndpoint\": { \"VpcEndpointId\": \"vpce-1a2b3c4d5e6f1a2b3\", \"VpcEndpointType\": \"Interface\", \"VpcId\": \"vpc-1a2b3c4d\", \"ServiceName\": \"com.amazonaws.us-east-1.s3\", \"State\": \"pending\", \"RouteTableIds\": [], \"SubnetIds\": [ \"subnet-1a2b3c4d\" ], \"Groups\": [ { \"GroupId\": \"sg-1a2b3c4d\", \"GroupName\": \"default\" } ], \"PrivateDnsEnabled\": false, \"RequesterManaged\": false, \"NetworkInterfaceIds\": [ \"eni-0b16f0581c8ac6877\" ], \"DnsEntries\": [ { \"DnsName\": \"*.vpce-1a2b3c4d5e6f1a2b3-9hnenorg.s3.us- east-1.vpce.amazonaws.com\", \"HostedZoneId\": \"Z7HUB22UULQXV\" }, { \"DnsName\": \"*.vpce-1a2b3c4d5e6f1a2b3-9hnenorg-us-east-1c.s3.us- east-1.vpce.amazonaws.com\", \"HostedZoneId\": \"Z7HUB22UULQXV\" } ], \"CreationTimestamp\": \"2021-03-05T14:46:16.030000+00:00\", \"Tags\": [ { \"Key\": \"service\", 작업 561\n\n Amazon Elastic Compute Cloud 개발자 안내서 \"Value\": \"S3\" } ], \"OwnerId\": \"123456789012\" } } 자세한 내용은 AWS PrivateLink 사용 설명서의 인터페이스 VPC 엔드포인트 생성을 참조하세 요. 예시 3: Gateway Load Balancer 엔드포인트 생성 다음 create-vpc-endpoint 예시에서는 VPC vpc-111122223333aabbc와 Gateway Load Balancer를 사용하여 구성된 서비스 사이에 Gateway Load Balancer 엔드포인트를 생성합니다. aws ec2 create-vpc-endpoint \\ --service-name com.amazonaws.vpce.us-east-1.vpce-svc-123123a1c43abc123 \\ --vpc-endpoint-type GatewayLoadBalancer \\ --vpc-id vpc-111122223333aabbc \\ --subnet-ids subnet-0011aabbcc2233445 출력: { \"VpcEndpoint\": { \"VpcEndpointId\": \"vpce-aabbaabbaabbaabba\", \"VpcEndpointType\": \"GatewayLoadBalancer\", \"VpcId\": \"vpc-111122223333aabbc\", \"ServiceName\": \"com.amazonaws.vpce.us-east-1.vpce-svc-123123a1c43abc123\", \"State\": \"pending\", \"SubnetIds\": [ \"subnet-0011aabbcc2233445\" ], \"RequesterManaged\": false, \"NetworkInterfaceIds\": [ \"eni-01010120203030405\" ], \"CreationTimestamp\": \"2020-11-11T08:06:03.522Z\", \"OwnerId\": \"123456789012\" } } 작업 562\n\n Amazon Elastic Compute Cloud 개발자 안내서 자세한 내용은 AWS PrivateLink 사용 설명서의 Gateway Load Balancer 엔드포인트를 참조하 세요. 예제 4: 리소스 엔드포인트 만들기 다음 create-vpc-endpoint 예제에서는 리소스 엔드포인트를 만듭니다. aws ec2 create-vpc-endpoint \\ --vpc-endpoint-type Resource \\ --vpc-id vpc-111122223333aabbc \\ --subnet-ids subnet-0011aabbcc2233445 \\ --resource-configuration-arn arn:aws:vpc-lattice-us- east-1:123456789012:resourceconfiguration/rcfg-0123abcde98765432 출력: { \"VpcEndpoint\": { \"VpcEndpointId\": \"vpce-00939a7ed9EXAMPLE\", \"VpcEndpointType\": \"Resource\", \"VpcId\": \"vpc-111122223333aabbc\", \"State\": \"Pending\", \"SubnetIds\": [ \"subnet-0011aabbcc2233445\" ], \"Groups\": [ { \"GroupId\": \"sg-03e2f15fbfc09b000\", \"GroupName\": \"default\" } ], \"IpAddressType\": \"IPV4\", \"PrivateDnsEnabled\": false, \"CreationTimestamp\": \"2025-02-06T23:38:49.525000+00:00\", \"Tags\": [], \"OwnerId\": \"123456789012\", \"ResourceConfigurationArn\": \"arn:aws:vpc-lattice:us- east-1:123456789012:resourceconfiguration/rcfg-0123abcde98765432\" } } 자세한 내용은 AWS PrivateLink 사용 설명서의 리소스 엔드포인트를 참조하시기 바랍니다. 작업 563\n\n Amazon Elastic Compute Cloud 개발자 안내서 예제 5: 서비스 네트워크 엔드포인트 만들기 다음 create-vpc-endpoint 예제에서는 서비스 네트워크 엔드포인트를 만듭니다. aws ec2 create-vpc-endpoint \\ --vpc-endpoint-type ServiceNetwork \\ --vpc-id vpc-111122223333aabbc \\ --subnet-ids subnet-0011aabbcc2233445 \\ --service-network-arn arn:aws:vpc-lattice:us- east-1:123456789012:servicenetwork/sn-0101abcd5432abcd0 \\ --security-group-ids sg-0123456789012abcd 출력: { \"VpcEndpoint\": { \"VpcEndpointId\": \"vpce-0f00567fa8EXAMPLE\", \"VpcEndpointType\": \"ServiceNetwork\", \"VpcId\": \"vpc-111122223333aabbc\", \"State\": \"Pending\", \"SubnetIds\": [ \"subnet-0011aabbcc2233445\" ], \"Groups\": [ { \"GroupId\": \"sg-0123456789012abcd\", \"GroupName\": \"my-security-group\" } ], \"IpAddressType\": \"IPV4\", \"PrivateDnsEnabled\": false, \"CreationTimestamp\": \"2025-02-06T23:44:20.449000+00:00\", \"Tags\": [], \"OwnerId\": \"123456789012\", \"ServiceNetworkArn\": \"arn:aws:vpc-lattice:us- east-1:123456789012:servicenetwork/sn-0101abcd5432abcd0\" } } 자세한 내용은 AWS PrivateLink 사용 설명서의 Service network endpoints를 참조하시기 바랍 니다. • API 세부 정보는 AWS CLI 명령 참조의 CreateVpcEndpoint 섹션을 참조하세요. 작업 564\n\n Amazon Elastic Compute Cloud PHP SDK for PHP Note 개발자 안내서 GitHub에 더 많은 내용이 있습니다. AWS 코드 예 리포지토리에서 전체 예를 찾고 설정 및 실행하는 방법을 배워보세요. /** * @param string $serviceName * @param string $vpcId * @param array $routeTableIds * @return array */ public function createVpcEndpoint(string $serviceName, string $vpcId, array $routeTableIds): array { try { $result = $this->ec2Client->createVpcEndpoint([ 'ServiceName' => $serviceName, 'VpcId' => $vpcId, 'RouteTableIds' => $routeTableIds, ]); return $result[\"VpcEndpoint\"]; } catch(Ec2Exception $caught){ echo \"There was a problem creating the VPC Endpoint: {$caught- >getAwsErrorMessage()}\\n\"; throw $caught; } } • API 세부 정보는 API 참조의 CreateVpcEndpointAWS SDK for PHP 를 참조하세요. 작업 565\n\n Amazon Elastic Compute Cloud PowerShell Tools for PowerShell V4 개발자 안내서 예제 1:이 예제에서는 VPC vpc-0fc1ff23f45b678eb의 서비스 com.amazonaws.eu-west-1.s3에 대한 새 VPC 엔드포인트를 생성합니다. New-EC2VpcEndpoint -ServiceName com.amazonaws.eu-west-1.s3 -VpcId vpc-0fc1ff23f45b678eb 출력: ClientToken VpcEndpoint ----------- ----------- Amazon.EC2.Model.VpcEndpoint • API 세부 정보는 Cmdlet 참조(V4)의 CreateVpcEndpoint를 참조하세요. AWS Tools for PowerShell Tools for PowerShell V5 예제 1:이 예제에서는 VPC vpc-0fc1ff23f45b678eb의 서비스 com.amazonaws.eu-west-1.s3에 대한 새 VPC 엔드포인트를 생성합니다. New-EC2VpcEndpoint -ServiceName com.amazonaws.eu-west-1.s3 -VpcId vpc-0fc1ff23f45b678eb 출력: ClientToken VpcEndpoint ----------- ----------- Amazon.EC2.Model.VpcEndpoint • API 세부 정보는 Cmdlet 참조(V5)의 CreateVpcEndpoint를 참조하세요. AWS Tools for PowerShell 작업 566\n\n Amazon Elastic Compute Cloud Python SDK for Python (Boto3) Note 개발자 안내서 GitHub에 더 많은 내용이 있습니다. AWS 코드 예 리포지토리에서 전체 예를 찾고 설정 및 실행하는 방법을 배워보세요. class VpcWrapper: \"\"\"Encapsulates Amazon Elastic Compute Cloud (Amazon EC2) Amazon Virtual Private Cloud actions.\"\"\" def __init__(self, ec2_client: boto3.client): \"\"\" Initializes the VpcWrapper with an EC2 client. :param ec2_client: A Boto3 Amazon EC2 client. This client provides low- level access to AWS EC2 services. \"\"\" self.ec2_client = ec2_client @classmethod def from_client(cls) -> \"VpcWrapper\": \"\"\" Creates a VpcWrapper instance with a default EC2 client. :return: An instance of VpcWrapper initialized with the default EC2 client. \"\"\" ec2_client = boto3.client(\"ec2\") return cls(ec2_client) def create_vpc_endpoint( self, vpc_id: str, service_name: str, route_table_ids: list[str] ) -> Dict[str, Any]: \"\"\" Creates a new VPC endpoint for the specified service and associates it with the specified route tables. 작업 567\n\n Amazon Elastic Compute Cloud 개발자 안내서 :param vpc_id: The ID of the VPC to create the endpoint in. :param service_name: The name of the service to create the endpoint for. :param route_table_ids: A list of IDs of the route tables to associate with the endpoint. :return: A dictionary representing the newly created VPC endpoint. \"\"\" try: response = self.ec2_client.create_vpc_endpoint( VpcId=vpc_id, ServiceName=service_name, RouteTableIds=route_table_ids, ) return response[\"VpcEndpoint\"] except ClientError as err: logger.error( \"Couldn't create VPC endpoint for service %s. Here's why: %s: %s\", service_name, err.response[\"Error\"][\"Code\"], err.response[\"Error\"][\"Message\"], ) raise • API 세부 정보는 SDK for Python (Boto3) API 참조의 CreateVpcEndpoint를 참조하세요. AWS AWS SDK 개발자 안내서 및 코드 예제의 전체 목록은 섹션을 참조하세요AWS SDK를 사용하여 Amazon EC2 리소스 생성. 이 주제에는 시작하기에 대한 정보와 이전 SDK 버전에 대한 세부 정보도 포함되어 있습니다. CLI로 CreateVpnConnection 사용 다음 코드 예시는 CreateVpnConnection의 사용 방법을 보여 줍니다. CLI AWS CLI 예시 1: 동적 라우팅을 사용하여\n\nAmazon Elastic Compute Cloud 개발자 안내서 :param vpc_id: The ID of the VPC to create the endpoint in. :param service_name: The name of the service to create the endpoint for. :param route_table_ids: A list of IDs of the route tables to associate with the endpoint. :return: A dictionary representing the newly created VPC endpoint. \"\"\" try: response = self.ec2_client.create_vpc_endpoint( VpcId=vpc_id, ServiceName=service_name, RouteTableIds=route_table_ids, ) return response[\"VpcEndpoint\"] except ClientError as err: logger.error( \"Couldn't create VPC endpoint for service %s. Here's why: %s: %s\", service_name, err.response[\"Error\"][\"Code\"], err.response[\"Error\"][\"Message\"], ) raise • API 세부 정보는 SDK for Python (Boto3) API 참조의 CreateVpcEndpoint를 참조하세요. AWS AWS SDK 개발자 안내서 및 코드 예제의 전체 목록은 섹션을 참조하세요AWS SDK를 사용하여 Amazon EC2 리소스 생성. 이 주제에는 시작하기에 대한 정보와 이전 SDK 버전에 대한 세부 정보도 포함되어 있습니다. CLI로 CreateVpnConnection 사용 다음 코드 예시는 CreateVpnConnection의 사용 방법을 보여 줍니다. CLI AWS CLI 예시 1: 동적 라우팅을 사용하여 VPN 연결 생성 작업 568\n\n Amazon Elastic Compute Cloud 개발자 안내서 다음 create-vpn-connection 예시에서는 지정된 가상 프라이빗 게이트웨이와 지정된 고객 게이트웨이 사이에 VPN 연결을 만들고 VPN 연결에 태그를 적용합니다. 출력에는 고객 게이트 웨이 디바이스의 구성 정보가 XML 형식으로 포함됩니다. aws ec2 create-vpn-connection \\ --type ipsec.1 \\ --customer-gateway-id cgw-001122334455aabbc \\ --vpn-gateway-id vgw-1a1a1a1a1a1a2b2b2 \\ --tag-specification 'ResourceType=vpn-connection,Tags=[{Key=Name,Value=BGP- VPN}]' 출력: { \"VpnConnection\": { \"CustomerGatewayConfiguration\": \"...configuration information...\", \"CustomerGatewayId\": \"cgw-001122334455aabbc\", \"Category\": \"VPN\", \"State\": \"pending\", \"VpnConnectionId\": \"vpn-123123123123abcab\", \"VpnGatewayId\": \"vgw-1a1a1a1a1a1a2b2b2\", \"Options\": { \"EnableAcceleration\": false, \"StaticRoutesOnly\": false, \"LocalIpv4NetworkCidr\": \"0.0.0.0/0\", \"RemoteIpv4NetworkCidr\": \"0.0.0.0/0\", \"TunnelInsideIpVersion\": \"ipv4\", \"TunnelOptions\": [ {}, {} ] }, \"Routes\": [], \"Tags\": [ { \"Key\": \"Name\", \"Value\": \"BGP-VPN\" } ] } } 작업 569\n\n Amazon Elastic Compute Cloud 개발자 안내서 자세한 내용은 SiteAWS Site-to-Site VPN 사용 설명서의 HowSite-to-Site VPN 작동 방식을 참 조하세요. AWS Site-to-Site 예시 2: 정적 라우팅을 사용하여 VPN 연결 생성 다음 create-vpn-connection 예시에서는 지정된 가상 프라이빗 게이트웨이와 지정된 고객 게이트웨이 간에 VPN 연결을 생성합니다. 옵션은 정적 라우팅을 지정합니다. 출력에는 고객 게 이트웨이 디바이스의 구성 정보가 XML 형식으로 포함됩니다. aws ec2 create-vpn-connection \\ --type ipsec.1 \\ --customer-gateway-id cgw-001122334455aabbc \\ --vpn-gateway-id vgw-1a1a1a1a1a1a2b2b2 \\ --options \"{\\\"StaticRoutesOnly\\\":true}\" 출력: { \"VpnConnection\": { \"CustomerGatewayConfiguration\": \"..configuration information...\", \"CustomerGatewayId\": \"cgw-001122334455aabbc\", \"Category\": \"VPN\", \"State\": \"pending\", \"VpnConnectionId\": \"vpn-123123123123abcab\", \"VpnGatewayId\": \"vgw-1a1a1a1a1a1a2b2b2\", \"Options\": { \"EnableAcceleration\": false, \"StaticRoutesOnly\": true, \"LocalIpv4NetworkCidr\": \"0.0.0.0/0\", \"RemoteIpv4NetworkCidr\": \"0.0.0.0/0\", \"TunnelInsideIpVersion\": \"ipv4\", \"TunnelOptions\": [ {}, {} ] }, \"Routes\": [], \"Tags\": [] } } 작업 570\n\n Amazon Elastic Compute Cloud 개발자 안내서 자세한 내용은 SiteAWS Site-to-Site VPN 사용 설명서의 HowSite-to-Site VPN 작동 방식을 참 조하세요. AWS Site-to-Site 예시 3: VPN 연결 생성 및 내부 CIDR 및 사전 공유 키 지정 다음 create-vpn-connection 예시에서는 VPN 연결을 생성하고 각 터널에 대 해 내부 IP 주소 CIDR 블록과 사용자 지정 사전 공유 키를 지정합니다. 지정된 값이 CustomerGatewayConfiguration 정보에 반환됩니다. aws ec2 create-vpn-connection \\ --type ipsec.1 \\ --customer-gateway-id cgw-001122334455aabbc \\ --vpn-gateway-id vgw-1a1a1a1a1a1a2b2b2 \\ --options TunnelOptions='[{TunnelInsideCidr=169.254.12.0/30,PreSharedKey=ExamplePreSharedKey1}, {TunnelInsideCidr=169.254.13.0/30,PreSharedKey=ExamplePreSharedKey2}]' 출력: { \"VpnConnection\": { \"CustomerGatewayConfiguration\": \"..configuration information...\", \"CustomerGatewayId\": \"cgw-001122334455aabbc\", \"Category\": \"VPN\", \"State\": \"pending\", \"VpnConnectionId\": \"vpn-123123123123abcab\", \"VpnGatewayId\": \"vgw-1a1a1a1a1a1a2b2b2\", \"Options\": { \"EnableAcceleration\": false, \"StaticRoutesOnly\": false, \"LocalIpv4NetworkCidr\": \"0.0.0.0/0\", \"RemoteIpv4NetworkCidr\": \"0.0.0.0/0\", \"TunnelInsideIpVersion\": \"ipv4\", \"TunnelOptions\": [ { \"OutsideIpAddress\": \"203.0.113.3\", \"TunnelInsideCidr\": \"169.254.12.0/30\", \"PreSharedKey\": \"ExamplePreSharedKey1\" }, { \"OutsideIpAddress\": \"203.0.113.5\", \"TunnelInsideCidr\": \"169.254.13.0/30\", 작업 571\n\n Amazon Elastic Compute Cloud 개발자 안내서 \"PreSharedKey\": \"ExamplePreSharedKey2\" } ] }, \"Routes\": [], \"Tags\": [] } } 자세한 내용은 SiteAWS Site-to-Site VPN 사용 설명서의 HowSite-to-Site VPN 작동 방식을 참 조하세요. AWS Site-to-Site 예시 4: IPv6 트래픽을 지원하는 VPN 연결 생성 다음 create-vpn-connection 예시에서는 지정된 전송 게이트웨이와 지정된 고객 게이트웨 이 간에 IPv6 트래픽을 지원하는 VPN 연결을 생성합니다. 두 터널의 터널 옵션은가 IKE 협상을 시작해야 AWS 한다고 지정합니다. aws ec2 create-vpn-connection \\ --type ipsec.1 \\ --transit-gateway-id tgw-12312312312312312 \\ --customer-gateway-id cgw-001122334455aabbc \\ --options TunnelInsideIpVersion=ipv6,TunnelOptions=[{StartupAction=start}, {StartupAction=start}] 출력: { \"VpnConnection\": { \"CustomerGatewayConfiguration\": \"..configuration information...\", \"CustomerGatewayId\": \"cgw-001122334455aabbc\", \"Category\": \"VPN\", \"State\": \"pending\", \"VpnConnectionId\": \"vpn-11111111122222222\", \"TransitGatewayId\": \"tgw-12312312312312312\", \"Options\": { \"EnableAcceleration\": false, \"StaticRoutesOnly\": false, \"LocalIpv6NetworkCidr\": \"::/0\", \"RemoteIpv6NetworkCidr\": \"::/0\", \"TunnelInsideIpVersion\": \"ipv6\", \"TunnelOptions\": [ 작업 572\n\n Amazon Elastic Compute Cloud { 개발자 안내서 \"OutsideIpAddress\": \"203.0.113.3\", \"StartupAction\": \"start\" }, { \"OutsideIpAddress\": \"203.0.113.5\", \"StartupAction\": \"start\" } ] }, \"Routes\": [], \"Tags\": [] } } 자세한 내용은 SiteAWS Site-to-Site VPN 사용 설명서의 HowSite-to-Site VPN 작동 방식을 참 조하세요. AWS Site-to-Site • API 세부 정보는 AWS CLI 명령 참조의 CreateVpnConnection 섹션을 참조하세요. PowerShell Tools for PowerShell V4 예제 1:이 예제에서는 지정된 가상 프라이빗 게이트웨이와 지정된 고객 게이트웨이 간에 VPN 연결을 생성합니다. 출력에는 네트워크 관리자에게 필요한 구성 정보가 XML 형식으로 포함됩 니다. New-EC2VpnConnection -Type ipsec.1 -CustomerGatewayId cgw-1a2b3c4d -VpnGatewayId vgw-1a2b3c4d 출력: CustomerGatewayConfiguration : [XML document] CustomerGatewayId : cgw-1a2b3c4d Options : Routes : {} State : pending Tags : {} Type : VgwTelemetry : {} VpnConnectionId : vpn-12345678 작업 573\n\n Amazon Elastic Compute Cloud 개발자 안내서 VpnGatewayId : vgw-1a2b3c4d 예제 2:이 예제에서는 VPN 연결을 생성하고 지정된 이름의 파일에 구성을 캡처합니다. (New-EC2VpnConnection -CustomerGatewayId cgw-1a2b3c4d -VpnGatewayId vgw-1a2b3c4d).CustomerGatewayConfiguration | Out-File C:\\path\\vpn- configuration.xml 예제 3:이 예제에서는 지정된 가상 프라이빗 게이트웨이와 지정된 고객 게이트웨이 간에 정적 라우팅을 사용하여 VPN 연결을 생성합니다. New-EC2VpnConnection -Type ipsec.1 -CustomerGatewayId cgw-1a2b3c4d -VpnGatewayId vgw-1a2b3c4d -Options_StaticRoutesOnly $true • API 세부 정보는 Cmdlet 참조(V4)의 CreateVpnConnection을 참조하세요. AWS Tools for PowerShell Tools for PowerShell V5 예제 1:이 예제에서는 지정된 가상 프라이빗 게이트웨이와 지정된 고객 게이트웨이 간에 VPN 연결을 생성합니다. 출력에는 네트워크 관리자에게 필요한 구성 정보가 XML 형식으로 포함됩 니다. New-EC2VpnConnection -Type ipsec.1 -CustomerGatewayId cgw-1a2b3c4d -VpnGatewayId vgw-1a2b3c4d 출력: CustomerGatewayConfiguration : [XML document] CustomerGatewayId : cgw-1a2b3c4d Options : Routes : {} State : pending Tags : {} Type : VgwTelemetry : {} VpnConnectionId : vpn-12345678 VpnGatewayId : vgw-1a2b3c4d 예제 2:이 예제에서는 VPN 연결을 생성하고 지정된 이름의 파일에 구성을 캡처합니다. 작업 574\n\n Amazon Elastic Compute Cloud 개발자 안내서 (New-EC2VpnConnection -CustomerGatewayId cgw-1a2b3c4d -VpnGatewayId vgw-1a2b3c4d).CustomerGatewayConfiguration | Out-File C:\\path\\vpn- configuration.xml 예제"}, {"ref": "/docs/aws-cli_pdf_cli-chap-welcome.pdf", "chunk_id": "aws/aws-cli_pdf_cli-chap-welcome_pdf#chunk376", "doc_id": "aws/aws-cli_pdf_cli-chap-welcome_pdf", "page": 2216, "anchor": "지정된 스냅샷을 복사하고 간단한 설명을 추가합니다. aws ec2 copy-snapshot \\ --region us-east-1 \\ --source-region us-west-2 \\ --source-snapshot-id snap-066877671789bd71b \\ --description 'This is my copied snapshot.' 출력: { \"SnapshotId\": \"snap-066877671789bd71b\" } Amazon EC2 2194\n\n AWS Command Line Interface 버전 2 사용 설명서 예시 2: 암호화되지 않은 스냅샷 복사 및 새 스냅샷 암호화 다음 copy-snapshot 명령은 지정된 암호화되지 않은 스냅샷을 us-west-2 리전에서 현재 리전 으로 복사하고 지정된 KMS 키를 사용하여 새 스냅샷을 암호화합니다. aws ec2 copy-snapshot \\ --source-region us-west-2 \\ --source-snapshot-id snap-066877671789bd71b \\ --encrypted \\ --kms-key-id alias/my-kms-key 출력: { \"SnapshotId\": \"snap-066877671789bd71b\" } 자세한 내용은 Amazon EBS 사용 설명서의 Amazon EBS 스냅샷 복사를 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 CopySnapshot 섹션을 참조하세요. create-capacity-reservation-fleet 다음 코드 예시는 create-capacity-reservation-fleet의 사용 방법을 보여 줍니다. AWS CLI 용량 예약 플릿 생성 다음 create-capacity-reservation-fleet 예시에서는 요청에 지정된 인스턴스 유형에 대 해 지정된 총 목표 용량까지 용량 예약 플릿을 생성합니다. 용량 예약 플릿이 용량을 예약하는 인스 턴스 수는 요청에 지정하는 총 목표 용량 및 인스턴스 유형 가중치에 따라 달라집니다. 사용할 인스 턴스 유형과 지정된 각 인스턴스 유형에 대한 우선 순위를 지정합니다. aws ec2 create-capacity-reservation-fleet \\ --total-target-capacity 24 \\ --allocation-strategy prioritized \\ --instance-match-criteria open \\ --tenancy default \\ --end-date 2022-12-31T23:59:59.000Z \\ Amazon EC2 2195\n\n AWS Command Line Interface 버전 2 사용 설명서 --instance-type-specifications file://instanceTypeSpecification.json instanceTypeSpecification.json의 콘텐츠: [ { \"InstanceType\": \"m5.xlarge\", \"InstancePlatform\": \"Linux/UNIX\", \"Weight\": 3.0, \"AvailabilityZone\":\"us-east-1a\", \"EbsOptimized\": true, \"Priority\" : 1 } ] 출력: { \"Status\": \"submitted\", \"TotalFulfilledCapacity\": 0.0, \"CapacityReservationFleetId\": \"crf-abcdef01234567890\", \"TotalTargetCapacity\": 24 } 용량 예약에 대한 자세한 내용은 Amazon EC2 사용 설명서의 용량 예약 플릿을 참조하세요. 인스턴스 유형 가중치 및 총 목표 용량에 대한 자세한 내용은 Amazon EC2 사용 설명서의 인스턴스 유형 가중치 및 총 목표 용량을 참조하세요. 지정된 인스턴스 유형에 대한 우선 순위 지정에 대한 자세한 내용은 Amazon EC2 사용 설명서의 할 당 전략 및 인스턴스 유형 우선 순위를 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 CreateCapacityReservationFleet 섹션을 참조하세요. create-capacity-reservation 다음 코드 예시는 create-capacity-reservation의 사용 방법을 보여 줍니다. AWS CLI 예시 1: 용량 예약 생성 Amazon EC2 2196\n\n AWS Command Line Interface 버전 2 사용 설명서 다음 create-capacity-reservation 예시에서는 eu-west-1a 가용 영역에 용량 예약을 생성 하여 Linux/Unix 운영 체제를 실행하는 t2.medium 인스턴스 3개를 시작할 수 있습니다. 기본적으 로 용량 예약은 오픈 인스턴스 매칭 기준으로 생성되며 임시 스토리지는 지원되지 않으며, 수동으 로 취소할 때까지 활성 상태로 유지됩니다. aws ec2 create-capacity-reservation \\ --availability-zone eu-west-1a \\ --instance-type t2.medium \\ --instance-platform Linux/UNIX \\ --instance-count 3 출력: { \"CapacityReservation\": { \"CapacityReservationId\": \"cr-1234abcd56EXAMPLE \", \"EndDateType\": \"unlimited\", \"AvailabilityZone\": \"eu-west-1a\", \"InstanceMatchCriteria\": \"open\", \"EphemeralStorage\": false, \"CreateDate\": \"2019-08-16T09:27:35.000Z\", \"AvailableInstanceCount\": 3, \"InstancePlatform\": \"Linux/UNIX\", \"TotalInstanceCount\": 3, \"State\": \"active\", \"Tenancy\": \"default\", \"EbsOptimized\": false, \"InstanceType\": \"t2.medium\" } } 예시 2: 지정된 날짜/시간에 자동으로 종료되는 용량 예약 생성 다음 create-capacity-reservation 예시에서는 eu-west-1a 가용 영역에 용량 예약을 생성 하여 Linux/Unix 운영 체제를 실행하는 m5.large 인스턴스 3개를 시작할 수 있습니다. 이 용량 예 약은 2019/8/31 23:59:59에 자동으로 종료됩니다. aws ec2 create-capacity-reservation \\ --availability-zone eu-west-1a \\ --instance-type m5.large \\ --instance-platform Linux/UNIX \\ Amazon EC2 2197\n\n AWS Command Line Interface 버전 2 사용 설명서 --instance-count 3 \\ --end-date-type limited \\ --end-date 2019-08-31T23:59:59Z 출력: { \"CapacityReservation\": { \"CapacityReservationId\": \"cr-1234abcd56EXAMPLE \", \"EndDateType\": \"limited\", \"AvailabilityZone\": \"eu-west-1a\", \"EndDate\": \"2019-08-31T23:59:59.000Z\", \"InstanceMatchCriteria\": \"open\", \"EphemeralStorage\": false, \"CreateDate\": \"2019-08-16T10:15:53.000Z\", \"AvailableInstanceCount\": 3, \"InstancePlatform\": \"Linux/UNIX\", \"TotalInstanceCount\": 3, \"State\": \"active\", \"Tenancy\": \"default\", \"EbsOptimized\": false, \"InstanceType\": \"m5.large\" } } 예시 3: 대상 인스턴스 시작만 허용하는 용량 예약 생성 다음 create-capacity-reservation 예시에서는 대상 인스턴스 시작만 허용하는 용량 예약을 생성합니다. aws ec2 create-capacity-reservation \\ --availability-zone eu-west-1a \\ --instance-type m5.large \\ --instance-platform Linux/UNIX \\ --instance-count 3 \\ --instance-match-criteria targeted 출력: { \"CapacityReservation\": { Amazon EC2 2198\n\n AWS Command Line Interface 버전 2 사용 설명서 \"CapacityReservationId\": \"cr-1234abcd56EXAMPLE \", \"EndDateType\": \"unlimited\", \"AvailabilityZone\": \"eu-west-1a\", \"InstanceMatchCriteria\": \"targeted\", \"EphemeralStorage\": false, \"CreateDate\": \"2019-08-16T10:21:57.000Z\", \"AvailableInstanceCount\": 3, \"InstancePlatform\": \"Linux/UNIX\", \"TotalInstanceCount\": 3, \"State\": \"active\", \"Tenancy\": \"default\", \"EbsOptimized\": false, \"InstanceType\": \"m5.large\" } } 자세한 내용은 Amazon EC2 사용 설명서의 용량 예약 생성을 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 CreateCapacityReservation 섹션을 참조하세요. create-carrier-gateway 다음 코드 예시는 create-carrier-gateway의 사용 방법을 보여 줍니다. AWS CLI 통신 사업자 게이트웨이 생성 다음 create-carrier-gateway 예시에서는 지정된 VPC에 대한 통신 사업자 게이트웨이를 생 성합니다. aws ec2 create-carrier-gateway \\ --vpc-id vpc-0c529aEXAMPLE1111 출력: { \"CarrierGateway\": { \"CarrierGatewayId\": \"cagw-0465cdEXAMPLE1111\", \"VpcId\": \"vpc-0c529aEXAMPLE1111\", \"State\": \"pending\", \"OwnerId\": \"123456789012\" Amazon EC2 2199\n\n AWS Command Line Interface 버전 2 사용 설명서 } } 자세한 내용은 AWS Wavelength 사용 설명서의 통신 사업자 게이트웨이를 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 CreateCarrierGateway 섹션을 참조하세요. create-client-vpn-endpoint 다음 코드 예시는 create-client-vpn-endpoint의 사용 방법을 보여 줍니다. AWS CLI Client VPN 엔드포인트 생성 다음 create-client-vpn-endpoint 예시에서는 상호 인증을 사용하는 클라이언트 VPN 엔드 포인트를 생성하고 클라이언트 CIDR 블록의 값을 지정합니다. aws ec2 create-client-vpn-endpoint \\ --client-cidr-block \"172.31.0.0/16\" \\ --server-certificate-arn arn:aws:acm:ap-south-1:123456789012:certificate/ a1b2c3d4-5678-90ab-cdef-11111EXAMPLE \\ --authentication-options Type=certificate- authentication,MutualAuthentication={ClientRootCertificateChainArn=arn:aws:acm:ap- south-1:123456789012:certificate/a1b2c3d4-5678-90ab-cdef-22222EXAMPLE} \\ --connection-log-options Enabled=false 출력: { \"ClientVpnEndpointId\": \"cvpn-endpoint-123456789123abcde\", \"Status\": { \"Code\": \"pending-associate\" }, \"DnsName\": \"cvpn-endpoint-123456789123abcde.prod.clientvpn.ap- south-1.amazonaws.com\" } 자세한 내용은 AWS Client VPN 관리자 안내서의 Client VPN 엔드포인트를 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 CreateClientVpnEndpoint 섹션을 참조하세요. Amazon EC2 2200\n\n AWS Command Line Interface create-client-vpn-route 버전 2 사용 설명서 다음 코드 예시는 create-client-vpn-route의 사용 방법을 보여 줍니다. AWS CLI Client VPN 엔드포인트 경로 생성 다음 create-client-vpn-route 예시에서는 클라이언트 VPN 엔드포인트의 지정된 서브넷에 대한 인터넷(0.0.0.0/0)으로의 경로를 추가합니다. aws ec2 create-client-vpn-route \\ --client-vpn-endpoint-id cvpn-endpoint-123456789123abcde \\ --destination-cidr-block 0.0.0.0/0 \\ --target-vpc-subnet-id subnet-0123456789abcabca 출력: { \"Status\": { \"Code\": \"creating\" } } 자세한 내용은 AWS Client VPN 관리자 안내서의 라우팅을 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 CreateClientVpnRoute 섹션을 참조하세요. create-coip-cidr 다음 코드 예시는 create-coip-cidr의 사용 방법을 보여 줍니다. AWS CLI 다양한 고객 소유 IP(CoIP) 주소 생성 다음 create-coip-cidr\n\n\\ --client-cidr-block \"172.31.0.0/16\" \\ --server-certificate-arn arn:aws:acm:ap-south-1:123456789012:certificate/ a1b2c3d4-5678-90ab-cdef-11111EXAMPLE \\ --authentication-options Type=certificate- authentication,MutualAuthentication={ClientRootCertificateChainArn=arn:aws:acm:ap- south-1:123456789012:certificate/a1b2c3d4-5678-90ab-cdef-22222EXAMPLE} \\ --connection-log-options Enabled=false 출력: { \"ClientVpnEndpointId\": \"cvpn-endpoint-123456789123abcde\", \"Status\": { \"Code\": \"pending-associate\" }, \"DnsName\": \"cvpn-endpoint-123456789123abcde.prod.clientvpn.ap- south-1.amazonaws.com\" } 자세한 내용은 AWS Client VPN 관리자 안내서의 Client VPN 엔드포인트를 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 CreateClientVpnEndpoint 섹션을 참조하세요. Amazon EC2 2200\n\n AWS Command Line Interface create-client-vpn-route 버전 2 사용 설명서 다음 코드 예시는 create-client-vpn-route의 사용 방법을 보여 줍니다. AWS CLI Client VPN 엔드포인트 경로 생성 다음 create-client-vpn-route 예시에서는 클라이언트 VPN 엔드포인트의 지정된 서브넷에 대한 인터넷(0.0.0.0/0)으로의 경로를 추가합니다. aws ec2 create-client-vpn-route \\ --client-vpn-endpoint-id cvpn-endpoint-123456789123abcde \\ --destination-cidr-block 0.0.0.0/0 \\ --target-vpc-subnet-id subnet-0123456789abcabca 출력: { \"Status\": { \"Code\": \"creating\" } } 자세한 내용은 AWS Client VPN 관리자 안내서의 라우팅을 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 CreateClientVpnRoute 섹션을 참조하세요. create-coip-cidr 다음 코드 예시는 create-coip-cidr의 사용 방법을 보여 줍니다. AWS CLI 다양한 고객 소유 IP(CoIP) 주소 생성 다음 create-coip-cidr 예시에서는 지정된 CoIP 풀에서 지정된 범위의 CoIP 주소를 생성합니 다. aws ec2 create-coip-cidr \\ --cidr 15.0.0.0/24 \\ Amazon EC2 2201\n\n AWS Command Line Interface 버전 2 사용 설명서 --coip-pool-id ipv4pool-coip-1234567890abcdefg 출력: { \"CoipCidr\": { \"Cidr\": \"15.0.0.0/24\", \"CoipPoolId\": \"ipv4pool-coip-1234567890abcdefg\", \"LocalGatewayRouteTableId\": \"lgw-rtb-abcdefg1234567890\" } } 자세한 내용은 AWS Outposts 사용 설명서의 고객 소유 IP 주소를 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 CreateCoipCidr 섹션을 참조하세요. create-coip-pool 다음 코드 예시는 create-coip-pool의 사용 방법을 보여 줍니다. AWS CLI 고객 소유 IP(CoIP) 주소 풀 생성 다음 create-coip-pool 예시에서는 지정된 로컬 게이트웨이 라우팅 테이블에 CoIP 주소에 대 한 CoIP 풀을 만듭니다. aws ec2 create-coip-pool \\ --local-gateway-route-table-id lgw-rtb-abcdefg1234567890 출력: { \"CoipPool\": { \"PoolId\": \"ipv4pool-coip-1234567890abcdefg\", \"LocalGatewayRouteTableId\": \"lgw-rtb-abcdefg1234567890\", \"PoolArn\": \"arn:aws:ec2:us-west-2:123456789012:coip-pool/ipv4pool- coip-1234567890abcdefg\" } } Amazon EC2 2202\n\n AWS Command Line Interface 버전 2 사용 설명서 자세한 내용은 AWS Outposts 사용 설명서의 고객 소유 IP 주소를 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 CreateCoipPool 섹션을 참조하세요. create-customer-gateway 다음 코드 예시는 create-customer-gateway의 사용 방법을 보여 줍니다. AWS CLI 고객 게이트웨이 생성 이 예시에서는 외부 인터페이스에 대해 지정된 IP 주소를 사용하여 고객 게이트웨이를 생성합니다. 명령: aws ec2 create-customer-gateway --type ipsec.1 --public-ip 12.1.2.3 --bgp-asn 65534 출력: { \"CustomerGateway\": { \"CustomerGatewayId\": \"cgw-0e11f167\", \"IpAddress\": \"12.1.2.3\", \"State\": \"available\", \"Type\": \"ipsec.1\", \"BgpAsn\": \"65534\" } } • API 세부 정보는 AWS CLI 명령 참조의 CreateCustomerGateway 섹션을 참조하세요. create-default-subnet 다음 코드 예시는 create-default-subnet의 사용 방법을 보여 줍니다. AWS CLI 기본 서브넷 생성 이 예시에서는 us-east-2a 가용 영역에 기본 서브넷을 생성합니다. Amazon EC2 2203\n\n AWS Command Line Interface 명령: 버전 2 사용 설명서 aws ec2 create-default-subnet --availability-zone us-east-2a { \"Subnet\": { \"AvailabilityZone\": \"us-east-2a\", \"Tags\": [], \"AvailableIpAddressCount\": 4091, \"DefaultForAz\": true, \"Ipv6CidrBlockAssociationSet\": [], \"VpcId\": \"vpc-1a2b3c4d\", \"State\": \"available\", \"MapPublicIpOnLaunch\": true, \"SubnetId\": \"subnet-1122aabb\", \"CidrBlock\": \"172.31.32.0/20\", \"AssignIpv6AddressOnCreation\": false } } • API 세부 정보는 AWS CLI 명령 참조의 CreateDefaultSubnet 섹션을 참조하세요. create-default-vpc 다음 코드 예시는 create-default-vpc의 사용 방법을 보여 줍니다. AWS CLI 기본 VPC 생성 이 예시에서는 기본 VPC를 생성합니다. 명령: aws ec2 create-default-vpc 출력: { \"Vpc\": { \"VpcId\": \"vpc-8eaae5ea\", \"InstanceTenancy\": \"default\", Amazon EC2 2204\n\n AWS Command Line Interface \"Tags\": [], \"Ipv6CidrBlockAssociationSet\": [], \"State\": \"pending\", \"DhcpOptionsId\": \"dopt-af0c32c6\", \"CidrBlock\": \"172.31.0.0/16\", \"IsDefault\": true } } 버전 2 사용 설명서 • API 세부 정보는 AWS CLI 명령 참조의 CreateDefaultVpc 섹션을 참조하세요. create-dhcp-options 다음 코드 예시는 create-dhcp-options의 사용 방법을 보여 줍니다. AWS CLI DHCP 옵션 세트 생성 다음 create-dhcp-options 예시에서는 도메인 이름, 도메인 이름 서버 및 NetBIOS 노드 유형 을 지정하는 DHCP 옵션 세트를 생성합니다. aws ec2 create-dhcp-options \\ --dhcp-configuration \\ \"Key=domain-name-servers,Values=10.2.5.1,10.2.5.2\" \\ \"Key=domain-name,Values=example.com\" \\ \"Key=netbios-node-type,Values=2\" 출력: { \"DhcpOptions\": { \"DhcpConfigurations\": [ { \"Key\": \"domain-name\", \"Values\": [ { \"Value\": \"example.com\" } ] }, { Amazon EC2 2205\n\n AWS Command Line Interface 버전 2 사용 설명서 \"Key\": \"domain-name-servers\", \"Values\": [ { \"Value\": \"10.2.5.1\" }, { \"Value\": \"10.2.5.2\" } ] }, { \"Key\": \"netbios-node-type\", \"Values\": [ { \"Value\": \"2\" } ] } ], \"DhcpOptionsId\": \"dopt-06d52773eff4c55f3\" } } • API 세부 정보는 AWS CLI 명령 참조의 CreateDhcpOptions 섹션을 참조하세요. create-egress-only-internet-gateway 다음 코드 예시는 create-egress-only-internet-gateway의 사용 방법을 보여 줍니다. AWS CLI 외부 전용 인터넷 게이트웨이 생성 이 예시에서는 지정된 VPC에 대한 외부 전용 인터넷 게이트웨이를 만듭니다. 명령: aws ec2 create-egress-only-internet-gateway --vpc-id vpc-0c62a468 출력: { Amazon EC2 2206\n\n AWS Command Line Interface 버전 2 사용 설명서 \"EgressOnlyInternetGateway\": { \"EgressOnlyInternetGatewayId\": \"eigw-015e0e244e24dfe8a\", \"Attachments\": [ { \"State\": \"attached\", \"VpcId\": \"vpc-0c62a468\" } ] } } • API 세부 정보는 AWS CLI 명령 참조의 CreateEgressOnlyInternetGateway 섹션을 참조하세요. create-fleet 다음 코드 예시는 create-fleet의 사용 방법을 보여 줍니다. AWS CLI 예시 1: 스팟 인스턴스를 기본 구매 모델로 시작하는 EC2 플릿 생성 다음 create-fleet 예시에서는 플릿을 시작하는 데 필요한 최소 파라미터인 시작 템플릿, 목표 용량, 기본 구매 모델을 사용하여 EC2 플릿을 생성합니다. 시작 템플릿은 시작 템플릿 ID와 버전 번 호로 식별됩니다. 플릿의 목표 용량은 인스턴스 2개이고 기본 구입 모델은 spot이므로 플릿이 스 팟 인스턴스 2개를 시작합니다. EC2 집합을 생성할 때 JSON 파일을 사용하여 시작할 인스턴스에 대한 정보를 지정하세요. aws ec2 create-fleet \\ --cli-input-json file://file_name.json file_name.json의 콘텐츠: { \"LaunchTemplateConfigs\": [ { \"LaunchTemplateSpecification\": { \"LaunchTemplateId\": \"lt-0e8c754449b27161c\", \"Version\": \"1\" } } Amazon EC2 2207\n\n AWS Command Line Interface ], \"TargetCapacitySpecification\": { \"TotalTargetCapacity\": 2, \"DefaultTargetCapacityType\": \"spot\" 버전 2 사용 설명서 } } 출력: { \"FleetId\": \"fleet-12a34b55-67cd-8ef9-ba9b-9208dEXAMPLE\" } 예시 2: 온디맨드 인스턴스를 기본 구매 모델로 시작하는 EC2 플릿 생성 다음 create-fleet 예시에서는 플릿을 시작하는 데 필요한 최소 파라미터인 시작 템플릿, 목표 용량, 기본 구매 모델을 사용하여 EC2 플릿을 생성합니다. 시작 템플릿은 시작 템플릿 ID와 버전 번 호로 식별됩니다. 플릿의 목표 용량은 인스턴스 2개이고 기본 구입 모델 on-demand이므로 플릿이 온디맨드 인스턴스 2개를 시작합니다. EC2 집합을 생성할 때 JSON 파일을 사용하여 시작할 인스턴스에 대한 정보를 지정하세요. aws ec2 create-fleet \\ --cli-input-json file://file_name.json file_name.json의\n\n번 호로 식별됩니다. 플릿의 목표 용량은 인스턴스 2개이고 기본 구입 모델은 spot이므로 플릿이 스 팟 인스턴스 2개를 시작합니다. EC2 집합을 생성할 때 JSON 파일을 사용하여 시작할 인스턴스에 대한 정보를 지정하세요. aws ec2 create-fleet \\ --cli-input-json file://file_name.json file_name.json의 콘텐츠: { \"LaunchTemplateConfigs\": [ { \"LaunchTemplateSpecification\": { \"LaunchTemplateId\": \"lt-0e8c754449b27161c\", \"Version\": \"1\" } } Amazon EC2 2207\n\n AWS Command Line Interface ], \"TargetCapacitySpecification\": { \"TotalTargetCapacity\": 2, \"DefaultTargetCapacityType\": \"spot\" 버전 2 사용 설명서 } } 출력: { \"FleetId\": \"fleet-12a34b55-67cd-8ef9-ba9b-9208dEXAMPLE\" } 예시 2: 온디맨드 인스턴스를 기본 구매 모델로 시작하는 EC2 플릿 생성 다음 create-fleet 예시에서는 플릿을 시작하는 데 필요한 최소 파라미터인 시작 템플릿, 목표 용량, 기본 구매 모델을 사용하여 EC2 플릿을 생성합니다. 시작 템플릿은 시작 템플릿 ID와 버전 번 호로 식별됩니다. 플릿의 목표 용량은 인스턴스 2개이고 기본 구입 모델 on-demand이므로 플릿이 온디맨드 인스턴스 2개를 시작합니다. EC2 집합을 생성할 때 JSON 파일을 사용하여 시작할 인스턴스에 대한 정보를 지정하세요. aws ec2 create-fleet \\ --cli-input-json file://file_name.json file_name.json의 콘텐츠: { \"LaunchTemplateConfigs\": [ { \"LaunchTemplateSpecification\": { \"LaunchTemplateId\": \"lt-0e8c754449b27161c\", \"Version\": \"1\" } } ], \"TargetCapacitySpecification\": { \"TotalTargetCapacity\": 2, \"DefaultTargetCapacityType\": \"on-demand\" } } Amazon EC2 2208\n\n AWS Command Line Interface 버전 2 사용 설명서 출력: { \"FleetId\": \"fleet-12a34b55-67cd-8ef9-ba9b-9208dEXAMPLE\" } 예시 3: 온디맨드 인스턴스를 기본 용량으로 시작하는 EC2 플릿 생성 다음 create-fleet 예시에서는 플릿의 총 목표 용량은 인스턴스 2개, 목표 용량은 온디맨드 인 스턴스 1개로 지정하는 EC2 플릿을 생성합니다. 기본 구매 모델은 spot입니다. 지정한 대로 플릿 은 온디맨드 인스턴스 1개를 시작하지만 총 목표 용량을 충족하려면 인스턴스를 하나 더 시작해 야 합니다. 차이에 대한 구매 모델이 TotalTargetCapacity – OnDemandTargetCapacity = DefaultTargetCapacityType으로 계산되므로 플릿에서 스팟 인스턴스 1개를 시작합니다. EC2 집합을 생성할 때 JSON 파일을 사용하여 시작할 인스턴스에 대한 정보를 지정하세요. aws ec2 create-fleet \\ --cli-input-json file://file_name.json file_name.json의 콘텐츠: { \"LaunchTemplateConfigs\": [ { \"LaunchTemplateSpecification\": { \"LaunchTemplateId\": \"lt-0e8c754449b27161c\", \"Version\": \"1\" } } ], \"TargetCapacitySpecification\": { \"TotalTargetCapacity\": 2, \"OnDemandTargetCapacity\":1, \"DefaultTargetCapacityType\": \"spot\" } } 출력: { Amazon EC2 2209\n\n AWS Command Line Interface 버전 2 사용 설명서 \"FleetId\": \"fleet-12a34b55-67cd-8ef9-ba9b-9208dEXAMPLE\" } 예시 4: 최저 가격 할당 전략을 사용하여 스팟 인스턴스를 시작하는 EC2 플릿 생성 스팟 인스턴스의 할당 전략이 지정되어 있지 않으면 기본 할당 전략인 lowest-price가 사용됩니 다. 다음 create-fleet 예시에서는 lowest-price 할당 전략을 사용하여 EC2 플릿을 생성합니 다. 시작 템플릿을 재정의하고 서로 인스턴스 유형은 다르지만 가중치 용량과 서브넷이 동일한 시 작 사양 3개가 있습니다. 총 목표 용량은 인스턴스 2개이고 기본 구매 모델은 spot입니다. EC2 집 합는 최저 가격이 지정된 시작 사양의 인스턴스 유형을 사용하여 스팟 인스턴스 2개를 시작합니다. EC2 집합을 생성할 때 JSON 파일을 사용하여 시작할 인스턴스에 대한 정보를 지정하세요. aws ec2 create-fleet \\ --cli-input-json file://file_name.jsonContents of file_name.json:: { \"LaunchTemplateConfigs\": [ { \"LaunchTemplateSpecification\": { \"LaunchTemplateId\": \"lt-0e8c754449b27161c\", \"Version\": \"1\" }, \"Overrides\": [ { \"InstanceType\": \"c4.large\", \"WeightedCapacity\": 1, \"SubnetId\": \"subnet-a4f6c5d3\" }, { \"InstanceType\": \"c3.large\", \"WeightedCapacity\": 1, \"SubnetId\": \"subnet-a4f6c5d3\" }, { \"InstanceType\": \"c5.large\", \"WeightedCapacity\": 1, \"SubnetId\": \"subnet-a4f6c5d3\" } ] } ], \"TargetCapacitySpecification\": { Amazon EC2 2210\n\n AWS Command Line Interface 버전 2 사용 설명서 \"TotalTargetCapacity\": 2, \"DefaultTargetCapacityType\": \"spot\" } } 출력: { \"FleetId\": \"fleet-12a34b55-67cd-8ef9-ba9b-9208dEXAMPLE\" } • API 세부 정보는 AWS CLI 명령 참조의 CreateFleet 섹션을 참조하세요. create-flow-logs 다음 코드 예시는 create-flow-logs의 사용 방법을 보여 줍니다. AWS CLI 예시 1: 흐름 로그 생성 다음 create-flow-logs 예시에서는 지정된 네트워크 인터페이스에 대해 거부된 모든 트래픽을 캡처하는 흐름 로그를 생성합니다. 흐름 로그는 지정된 IAM 역할의 권한을 사용하여 CloudWatch Logs의 로그 그룹에 전달됩니다. aws ec2 create-flow-logs \\ --resource-type NetworkInterface \\ --resource-ids eni-11223344556677889 \\ --traffic-type REJECT \\ --log-group-name my-flow-logs \\ --deliver-logs-permission-arn arn:aws:iam::123456789101:role/publishFlowLogs 출력: { \"ClientToken\": \"so0eNA2uSHUNlHI0S2cJ305GuIX1CezaRdGtexample\", \"FlowLogIds\": [ \"fl-12345678901234567\" ], Amazon EC2 2211\n\n AWS Command Line Interface 버전 2 사용 설명서 \"Unsuccessful\": [] } 자세한 내용은 Amazon VPC 사용 설명서의 VPC 흐름 로그를 참조하세요. 예시 2: 사용자 지정 형식으로 흐름 로그 생성 다음 create-flow-logs 예시에서는 지정된 VPC의 모든 트래픽을 캡처하고 Amazon S3 버킷 에 흐름 로그를 전송하는 흐름 로그를 생성합니다. --log-format 파라미터는 흐름 로그 레코드 의 사용자 지정 형식을 지정합니다. Windows에서 이 명령을 실행하려면 작은따옴표(')를 큰따옴표 (\")로 변경하세요. aws ec2 create-flow-logs \\ --resource-type VPC \\ --resource-ids vpc-00112233344556677 \\ --traffic-type ALL \\ --log-destination-type s3 \\ --log-destination arn:aws:s3:::flow-log-bucket/my-custom-flow-logs/ \\ --log-format '${version} ${vpc-id} ${subnet-id} ${instance-id} ${srcaddr} ${dstaddr} ${srcport} ${dstport} ${protocol} ${tcp-flags} ${type} ${pkt-srcaddr} ${pkt-dstaddr}' 자세한 내용은 Amazon VPC 사용 설명서의 VPC 흐름 로그를 참조하세요. 예시 3: 최대 집계 간격이 1분인 흐름 로그 생성 다음 create-flow-logs 예시에서는 지정된 VPC의 모든 트래픽을 캡처하고 Amazon S3 버킷에 흐름 로그를 전송하는 흐름 로그를 생성합니다. --max-aggregation-interval 파라미터는 최 대 60초(1분)의 집계 간격을 지정합니다. aws ec2 create-flow-logs \\ --resource-type VPC \\ --resource-ids vpc-00112233344556677 \\ --traffic-type ALL \\ --log-destination-type s3 \\ --log-destination arn:aws:s3:::flow-log-bucket/my-custom-flow-logs/ \\ --max-aggregation-interval 60 자세한 내용은 Amazon VPC 사용 설명서의 VPC 흐름 로그를 참조하세요. • API 세부 정보는 AWS CLI 명령 참조의 CreateFlowLogs 섹션을 참조하세요. Amazon EC2 2212\n\n AWS Command Line Interface create-fpga-image 버전 2 사용 설명서 다음 코드 예시는 create-fpga-image의 사용 방법을 보여 줍니다. AWS CLI Amazon FPGA 이미지 생성 이 예시에서는 지정된 버킷의 지정된 tarball에서 AFI를 생성합니다. 명령: aws ec2 create-fpga-image --name my-afi --description test-afi --input-storage- location Bucket=my-fpga-bucket,Key=dcp/17_12_22-103226.Developer_CL.tar --logs- storage-location Bucket=my-fpga-bucket,Key=logs 출력: { \"FpgaImageId\": \"afi-0d123e123bfc85abc\", \"FpgaImageGlobalId\": \"agfi-123cb27b5e84a0abc\" } • API 세부 정보는 AWS CLI 명령 참조의 CreateFpgaImage 섹션을 참조하세요. create-image 다음 코드 예시는 create-image의 사용 방법을 보여 줍니다. AWS CLI 예시 1: Amazon EBS 지원 인스턴스에서 AMI 생성 다음 create-image 예시에서는 지정된 인스턴스에서 AMI를 생성합니다. aws ec2 create-image \\ --instance-id i-1234567890abcdef0 \\ --name \"My server\" \\ --description \"An AMI for my server\" 출력: Amazon EC2 2213\n\n AWS Command Line Interface 버전 2 사용 설명서 { \"ImageId\": \"ami-abcdef01234567890\" } AMI에 대한 블록 디바이스 매핑을 지정하는 방법에 대한 자세한 내용은 Amazon EC2 사용 설명 서의 AMI에 대한 블록 디바이스 매핑 지정을 참조하세요. 예시 2:"}, {"ref": "/docs/ec2-dg.pdf", "chunk_id": "aws/ec2-dg_pdf#chunk261", "doc_id": "aws/ec2-dg_pdf", "page": 1417, "anchor": "Amazon Elastic Compute Cloud 개발자 안내서 echo \"Using Availability Zones: $AZ1 and $AZ2\" # Create public subnets echo \"Creating public subnet in $AZ1...\" PUBLIC_SUBNET_AZ1=$(aws ec2 create-subnet \\ --vpc-id \"$VPC_ID\" \\ --cidr-block 10.0.0.0/24 \\ --availability-zone \"$AZ1\" \\ --tag-specifications 'ResourceType=subnet,Tags=[{Key=Name,Value=Public-Subnet- AZ1}]' \\ --query 'Subnet.SubnetId' \\ --output text) if [ -z \"$PUBLIC_SUBNET_AZ1\" ]; then handle_error \"Failed to create public subnet in AZ1\" fi CREATED_RESOURCES+=(\"SUBNET:$PUBLIC_SUBNET_AZ1\") echo \"Public subnet created in $AZ1 with ID: $PUBLIC_SUBNET_AZ1\" echo \"Creating public subnet in $AZ2...\" PUBLIC_SUBNET_AZ2=$(aws ec2 create-subnet \\ --vpc-id \"$VPC_ID\" \\ --cidr-block 10.0.1.0/24 \\ --availability-zone \"$AZ2\" \\ --tag-specifications 'ResourceType=subnet,Tags=[{Key=Name,Value=Public-Subnet- AZ2}]' \\ --query 'Subnet.SubnetId' \\ --output text) if [ -z \"$PUBLIC_SUBNET_AZ2\" ]; then handle_error \"Failed to create public subnet in AZ2\" fi CREATED_RESOURCES+=(\"SUBNET:$PUBLIC_SUBNET_AZ2\") echo \"Public subnet created in $AZ2 with ID: $PUBLIC_SUBNET_AZ2\" # Create private subnets echo \"Creating private subnet in $AZ1...\" PRIVATE_SUBNET_AZ1=$(aws ec2 create-subnet \\ --vpc-id \"$VPC_ID\" \\ --cidr-block 10.0.2.0/24 \\ --availability-zone \"$AZ1\" \\ Amazon VPC 시작하기 1408\n\n Amazon Elastic Compute Cloud 개발자 안내서 --tag-specifications 'ResourceType=subnet,Tags=[{Key=Name,Value=Private-Subnet- AZ1}]' \\ --query 'Subnet.SubnetId' \\ --output text) if [ -z \"$PRIVATE_SUBNET_AZ1\" ]; then handle_error \"Failed to create private subnet in AZ1\" fi CREATED_RESOURCES+=(\"SUBNET:$PRIVATE_SUBNET_AZ1\") echo \"Private subnet created in $AZ1 with ID: $PRIVATE_SUBNET_AZ1\" echo \"Creating private subnet in $AZ2...\" PRIVATE_SUBNET_AZ2=$(aws ec2 create-subnet \\ --vpc-id \"$VPC_ID\" \\ --cidr-block 10.0.3.0/24 \\ --availability-zone \"$AZ2\" \\ --tag-specifications 'ResourceType=subnet,Tags=[{Key=Name,Value=Private-Subnet- AZ2}]' \\ --query 'Subnet.SubnetId' \\ --output text) if [ -z \"$PRIVATE_SUBNET_AZ2\" ]; then handle_error \"Failed to create private subnet in AZ2\" fi CREATED_RESOURCES+=(\"SUBNET:$PRIVATE_SUBNET_AZ2\") echo \"Private subnet created in $AZ2 with ID: $PRIVATE_SUBNET_AZ2\" # Create Internet Gateway echo \"Creating Internet Gateway...\" IGW_ID=$(aws ec2 create-internet-gateway \\ --tag-specifications 'ResourceType=internet- gateway,Tags=[{Key=Name,Value=MyIGW}]' \\ --query 'InternetGateway.InternetGatewayId' \\ --output text) if [ -z \"$IGW_ID\" ]; then handle_error \"Failed to create Internet Gateway\" fi CREATED_RESOURCES+=(\"INTERNET_GATEWAY:$IGW_ID\") echo \"Internet Gateway created with ID: $IGW_ID\" Amazon VPC 시작하기 1409\n\n Amazon Elastic Compute Cloud 개발자 안내서 # Attach Internet Gateway to VPC echo \"Attaching Internet Gateway to VPC...\" aws ec2 attach-internet-gateway --internet-gateway-id \"$IGW_ID\" --vpc-id \"$VPC_ID\" || handle_error \"Failed to attach Internet Gateway to VPC\" # Create public route table echo \"Creating public route table...\" PUBLIC_RT=$(aws ec2 create-route-table \\ --vpc-id \"$VPC_ID\" \\ --tag-specifications 'ResourceType=route-table,Tags=[{Key=Name,Value=Public- RT}]' \\ --query 'RouteTable.RouteTableId' \\ --output text) if [ -z \"$PUBLIC_RT\" ]; then handle_error \"Failed to create public route table\" fi CREATED_RESOURCES+=(\"ROUTE_TABLE:$PUBLIC_RT\") echo \"Public route table created with ID: $PUBLIC_RT\" # Add route to Internet Gateway echo \"Adding route to Internet Gateway in public route table...\" aws ec2 create-route --route-table-id \"$PUBLIC_RT\" --destination-cidr-block 0.0.0.0/0 --gateway-id \"$IGW_ID\" || handle_error \"Failed to add route to Internet Gateway\" # Associate public subnets with public route table echo \"Associating public subnet in $AZ1 with public route table...\" PUBLIC_RT_ASSOC_1=$(aws ec2 associate-route-table --route-table-id \"$PUBLIC_RT\" --subnet-id \"$PUBLIC_SUBNET_AZ1\" --query 'AssociationId' --output text) if [ -z \"$PUBLIC_RT_ASSOC_1\" ]; then handle_error \"Failed to associate public subnet in AZ1 with public route table\" fi CREATED_RESOURCES+=(\"ROUTE_TABLE_ASSOCIATION:$PUBLIC_RT_ASSOC_1\") echo \"Associating public subnet in $AZ2 with public route table...\" PUBLIC_RT_ASSOC_2=$(aws ec2 associate-route-table --route-table-id \"$PUBLIC_RT\" --subnet-id \"$PUBLIC_SUBNET_AZ2\" --query 'AssociationId' --output text) if [ -z \"$PUBLIC_RT_ASSOC_2\" ]; then handle_error \"Failed to associate public subnet in AZ2 with public route table\" Amazon VPC 시작하기 1410\n\n Amazon Elastic Compute Cloud fi 개발자 안내서 CREATED_RESOURCES+=(\"ROUTE_TABLE_ASSOCIATION:$PUBLIC_RT_ASSOC_2\") # Create private route table echo \"Creating private route table...\" PRIVATE_RT=$(aws ec2 create-route-table \\ --vpc-id \"$VPC_ID\" \\ --tag-specifications 'ResourceType=route-table,Tags=[{Key=Name,Value=Private- RT}]' \\ --query 'RouteTable.RouteTableId' \\ --output text) if [ -z \"$PRIVATE_RT\" ]; then handle_error \"Failed to create private route table\" fi CREATED_RESOURCES+=(\"ROUTE_TABLE:$PRIVATE_RT\") echo \"Private route table created with ID: $PRIVATE_RT\" # Associate private subnets with private route table echo \"Associating private subnet in $AZ1 with private route table...\" PRIVATE_RT_ASSOC_1=$(aws ec2 associate-route-table --route-table-id \"$PRIVATE_RT\" --subnet-id \"$PRIVATE_SUBNET_AZ1\" --query 'AssociationId' --output text) if [ -z \"$PRIVATE_RT_ASSOC_1\" ]; then handle_error \"Failed to associate private subnet in AZ1 with private route table\" fi CREATED_RESOURCES+=(\"ROUTE_TABLE_ASSOCIATION:$PRIVATE_RT_ASSOC_1\") echo \"Associating private subnet in $AZ2 with private route table...\" PRIVATE_RT_ASSOC_2=$(aws ec2 associate-route-table --route-table-id \"$PRIVATE_RT\" --subnet-id \"$PRIVATE_SUBNET_AZ2\" --query 'AssociationId' --output text) if [ -z \"$PRIVATE_RT_ASSOC_2\" ]; then handle_error \"Failed to associate private subnet in AZ2 with private route table\" fi CREATED_RESOURCES+=(\"ROUTE_TABLE_ASSOCIATION:$PRIVATE_RT_ASSOC_2\") # Allocate Elastic IP for NAT Gateway Amazon VPC 시작하기 1411\n\n Amazon Elastic Compute Cloud 개발자 안내서 echo \"Allocating Elastic IP for NAT Gateway...\" EIP_ALLOC=$(aws ec2 allocate-address --domain vpc --query 'AllocationId' --output text) if [ -z \"$EIP_ALLOC\" ]; then handle_error \"Failed to allocate Elastic IP\" fi CREATED_RESOURCES+=(\"EIP:$EIP_ALLOC\") echo \"Elastic IP allocated with ID: $EIP_ALLOC\" # Create NAT Gateway echo \"Creating NAT Gateway in public subnet in $AZ1...\" NAT_GW=$(aws ec2 create-nat-gateway \\ --subnet-id \"$PUBLIC_SUBNET_AZ1\" \\ --allocation-id \"$EIP_ALLOC\" \\ --tag-specifications 'ResourceType=natgateway,Tags=[{Key=Name,Value=MyNATGateway}]' \\ --query 'NatGateway.NatGatewayId' \\ --output text) if [ -z \"$NAT_GW\" ]; then handle_error \"Failed to create NAT Gateway\" fi CREATED_RESOURCES+=(\"NAT_GATEWAY:$NAT_GW\") echo \"NAT Gateway created with ID: $NAT_GW\" # Wait for NAT Gateway to be available echo \"Waiting for NAT Gateway to be available...\" aws ec2 wait nat-gateway-available --nat-gateway-ids \"$NAT_GW\" || handle_error \"NAT Gateway did not become available\" # Add route to NAT Gateway in private route table echo \"Adding route to NAT Gateway in private route table...\" aws ec2 create-route --route-table-id \"$PRIVATE_RT\" --destination-cidr-block 0.0.0.0/0 --nat-gateway-id \"$NAT_GW\" || handle_error \"Failed to add route to NAT Gateway\" # Enable auto-assign public IP for instances in public subnets echo \"Enabling auto-assign public IP for instances in public subnet in $AZ1...\" aws ec2 modify-subnet-attribute --subnet-id \"$PUBLIC_SUBNET_AZ1\" --map-public- ip-on-launch || handle_error \"Failed to enable auto-assign public IP for public subnet in AZ1\" Amazon VPC 시작하기 1412\n\n Amazon Elastic Compute Cloud 개발자 안내서 echo \"Enabling auto-assign public IP for instances in public subnet in $AZ2...\" aws ec2 modify-subnet-attribute --subnet-id \"$PUBLIC_SUBNET_AZ2\"\n\nNAT Gateway\" fi CREATED_RESOURCES+=(\"NAT_GATEWAY:$NAT_GW\") echo \"NAT Gateway created with ID: $NAT_GW\" # Wait for NAT Gateway to be available echo \"Waiting for NAT Gateway to be available...\" aws ec2 wait nat-gateway-available --nat-gateway-ids \"$NAT_GW\" || handle_error \"NAT Gateway did not become available\" # Add route to NAT Gateway in private route table echo \"Adding route to NAT Gateway in private route table...\" aws ec2 create-route --route-table-id \"$PRIVATE_RT\" --destination-cidr-block 0.0.0.0/0 --nat-gateway-id \"$NAT_GW\" || handle_error \"Failed to add route to NAT Gateway\" # Enable auto-assign public IP for instances in public subnets echo \"Enabling auto-assign public IP for instances in public subnet in $AZ1...\" aws ec2 modify-subnet-attribute --subnet-id \"$PUBLIC_SUBNET_AZ1\" --map-public- ip-on-launch || handle_error \"Failed to enable auto-assign public IP for public subnet in AZ1\" Amazon VPC 시작하기 1412\n\n Amazon Elastic Compute Cloud 개발자 안내서 echo \"Enabling auto-assign public IP for instances in public subnet in $AZ2...\" aws ec2 modify-subnet-attribute --subnet-id \"$PUBLIC_SUBNET_AZ2\" --map-public- ip-on-launch || handle_error \"Failed to enable auto-assign public IP for public subnet in AZ2\" # Create security group for web servers echo \"Creating security group for web servers...\" WEB_SG=$(aws ec2 create-security-group \\ --group-name \"WebServerSG-$(date +%s)\" \\ --description \"Security group for web servers\" \\ --vpc-id \"$VPC_ID\" \\ --query 'GroupId' \\ --output text) if [ -z \"$WEB_SG\" ]; then handle_error \"Failed to create security group for web servers\" fi CREATED_RESOURCES+=(\"SECURITY_GROUP:$WEB_SG\") echo \"Security group for web servers created with ID: $WEB_SG\" # Allow HTTP and HTTPS traffic echo \"Allowing HTTP traffic to web servers security group...\" aws ec2 authorize-security-group-ingress --group-id \"$WEB_SG\" --protocol tcp -- port 80 --cidr 0.0.0.0/0 || handle_error \"Failed to allow HTTP traffic\" echo \"Allowing HTTPS traffic to web servers security group...\" aws ec2 authorize-security-group-ingress --group-id \"$WEB_SG\" --protocol tcp -- port 443 --cidr 0.0.0.0/0 || handle_error \"Failed to allow HTTPS traffic\" # Note: In a production environment, you should restrict the source IP ranges for security echo \"NOTE: In a production environment, you should restrict the source IP ranges for HTTP and HTTPS traffic\" # Create security group for database servers echo \"Creating security group for database servers...\" DB_SG=$(aws ec2 create-security-group \\ --group-name \"DBServerSG-$(date +%s)\" \\ --description \"Security group for database servers\" \\ --vpc-id \"$VPC_ID\" \\ --query 'GroupId' \\ --output text) Amazon VPC 시작하기 1413\n\n Amazon Elastic Compute Cloud 개발자 안내서 if [ -z \"$DB_SG\" ]; then handle_error \"Failed to create security group for database servers\" fi CREATED_RESOURCES+=(\"SECURITY_GROUP:$DB_SG\") echo \"Security group for database servers created with ID: $DB_SG\" # Allow MySQL/Aurora traffic from web servers only echo \"Allowing MySQL/Aurora traffic from web servers to database servers...\" aws ec2 authorize-security-group-ingress --group-id \"$DB_SG\" --protocol tcp -- port 3306 --source-group \"$WEB_SG\" || handle_error \"Failed to allow MySQL/Aurora traffic\" # Verify VPC configuration echo \"Verifying VPC configuration...\" echo \"VPC:\" aws ec2 describe-vpcs --vpc-id \"$VPC_ID\" || handle_error \"Failed to describe VPC\" echo \"Subnets:\" aws ec2 describe-subnets --filters \"Name=vpc-id,Values=$VPC_ID\" || handle_error \"Failed to describe subnets\" echo \"Route tables:\" aws ec2 describe-route-tables --filters \"Name=vpc-id,Values=$VPC_ID\" || handle_error \"Failed to describe route tables\" echo \"Internet gateway:\" aws ec2 describe-internet-gateways --filters \"Name=attachment.vpc-id,Values= $VPC_ID\" || handle_error \"Failed to describe Internet Gateway\" echo \"NAT gateway:\" aws ec2 describe-nat-gateways --filter \"Name=vpc-id,Values=$VPC_ID\" || handle_error \"Failed to describe NAT Gateway\" echo \"Security groups:\" aws ec2 describe-security-groups --filters \"Name=vpc-id,Values=$VPC_ID\" || handle_error \"Failed to describe security groups\" echo \"\" # Summary of created resources echo \"VPC creation completed successfully!\" echo \"Summary of created resources:\" echo \"- VPC: $VPC_ID\" Amazon VPC 시작하기 1414\n\n Amazon Elastic Compute Cloud 개발자 안내서 echo \"- Public Subnet in $AZ1: $PUBLIC_SUBNET_AZ1\" echo \"- Public Subnet in $AZ2: $PUBLIC_SUBNET_AZ2\" echo \"- Private Subnet in $AZ1: $PRIVATE_SUBNET_AZ1\" echo \"- Private Subnet in $AZ2: $PRIVATE_SUBNET_AZ2\" echo \"- Internet Gateway: $IGW_ID\" echo \"- Public Route Table: $PUBLIC_RT\" echo \"- Private Route Table: $PRIVATE_RT\" echo \"- Elastic IP: $EIP_ALLOC\" echo \"- NAT Gateway: $NAT_GW\" echo \"- Web Servers Security Group: $WEB_SG\" echo \"- Database Servers Security Group: $DB_SG\" # Deploy EC2 instances echo \"\" echo \"Deploying EC2 instances...\" # Create key pair for SSH access KEY_NAME=\"vpc-tutorial-key-$(date +%s)\" echo \"Creating key pair $KEY_NAME...\" aws ec2 create-key-pair --key-name \"$KEY_NAME\" --query 'KeyMaterial' --output text > \"${KEY_NAME}.pem\" || handle_error \"Failed to create key pair\" chmod 400 \"${KEY_NAME}.pem\" echo \"Key pair saved to ${KEY_NAME}.pem\" CREATED_RESOURCES+=(\"KEY_PAIR:$KEY_NAME\") # Get latest Amazon Linux 2 AMI echo \"Getting latest Amazon Linux 2 AMI...\" AMI_ID=$(aws ec2 describe-images --owners amazon \\ --filters \"Name=name,Values=amzn2-ami-hvm-*-x86_64-gp2\" \"Name=state,Values=available\" \\ --query \"sort_by(Images, &CreationDate)[-1].ImageId\" --output text) || handle_error \"Failed to get AMI\" echo \"Using AMI: $AMI_ID\" # Launch web server in public subnet echo \"Launching web server in public subnet...\" WEB_INSTANCE=$(aws ec2 run-instances \\ --image-id \"$AMI_ID\" \\ --count 1 \\ --instance-type t2.micro \\ --key-name \"$KEY_NAME\" \\ --security-group-ids \"$WEB_SG\" \\ --subnet-id \"$PUBLIC_SUBNET_AZ1\" \\ --associate-public-ip-address \\ Amazon VPC 시작하기 1415\n\n Amazon Elastic Compute Cloud 개발자 안내서 --user-data '#!/bin/bash yum update -y yum install -y httpd systemctl start httpd systemctl enable httpd echo \"<h1>Hello from $(hostname -f) in the public subnet</h1>\" > /var/www/ html/index.html' \\ --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value=WebServer}]' \\ --query 'Instances[0].InstanceId' \\ --output text) || handle_error \"Failed to launch web server\" echo \"Web server instance created with ID: $WEB_INSTANCE\" CREATED_RESOURCES+=(\"INSTANCE:$WEB_INSTANCE\") # Wait for web server to be running echo \"Waiting for web server to be running...\" aws ec2 wait instance-running --instance-ids \"$WEB_INSTANCE\" # Get web server public IP WEB_PUBLIC_IP=$(aws ec2 describe-instances --instance-ids \"$WEB_INSTANCE\" \\ --query 'Reservations[0].Instances[0].PublicIpAddress' --output text) echo \"Web server public IP: $WEB_PUBLIC_IP\" echo \"You can access the web server at: http://$WEB_PUBLIC_IP\" # Launch database server in private subnet echo \"Launching database server in private subnet...\" DB_INSTANCE=$(aws ec2 run-instances \\ --image-id \"$AMI_ID\"\n\nt2.micro \\ --key-name \"$KEY_NAME\" \\ --security-group-ids \"$WEB_SG\" \\ --subnet-id \"$PUBLIC_SUBNET_AZ1\" \\ --associate-public-ip-address \\ Amazon VPC 시작하기 1415\n\n Amazon Elastic Compute Cloud 개발자 안내서 --user-data '#!/bin/bash yum update -y yum install -y httpd systemctl start httpd systemctl enable httpd echo \"<h1>Hello from $(hostname -f) in the public subnet</h1>\" > /var/www/ html/index.html' \\ --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value=WebServer}]' \\ --query 'Instances[0].InstanceId' \\ --output text) || handle_error \"Failed to launch web server\" echo \"Web server instance created with ID: $WEB_INSTANCE\" CREATED_RESOURCES+=(\"INSTANCE:$WEB_INSTANCE\") # Wait for web server to be running echo \"Waiting for web server to be running...\" aws ec2 wait instance-running --instance-ids \"$WEB_INSTANCE\" # Get web server public IP WEB_PUBLIC_IP=$(aws ec2 describe-instances --instance-ids \"$WEB_INSTANCE\" \\ --query 'Reservations[0].Instances[0].PublicIpAddress' --output text) echo \"Web server public IP: $WEB_PUBLIC_IP\" echo \"You can access the web server at: http://$WEB_PUBLIC_IP\" # Launch database server in private subnet echo \"Launching database server in private subnet...\" DB_INSTANCE=$(aws ec2 run-instances \\ --image-id \"$AMI_ID\" \\ --count 1 \\ --instance-type t2.micro \\ --key-name \"$KEY_NAME\" \\ --security-group-ids \"$DB_SG\" \\ --subnet-id \"$PRIVATE_SUBNET_AZ1\" \\ --user-data '#!/bin/bash yum update -y yum install -y mariadb-server systemctl start mariadb systemctl enable mariadb' \\ --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value=DBServer}]' \\ --query 'Instances[0].InstanceId' \\ --output text) || handle_error \"Failed to launch database server\" echo \"Database server instance created with ID: $DB_INSTANCE\" CREATED_RESOURCES+=(\"INSTANCE:$DB_INSTANCE\") Amazon VPC 시작하기 1416\n\n Amazon Elastic Compute Cloud 개발자 안내서 # Wait for database server to be running echo \"Waiting for database server to be running...\" aws ec2 wait instance-running --instance-ids \"$DB_INSTANCE\" # Get database server private IP DB_PRIVATE_IP=$(aws ec2 describe-instances --instance-ids \"$DB_INSTANCE\" \\ --query 'Reservations[0].Instances[0].PrivateIpAddress' --output text) echo \"Database server private IP: $DB_PRIVATE_IP\" echo \"EC2 instances deployed successfully!\" echo \"- Web Server (Public): $WEB_INSTANCE ($WEB_PUBLIC_IP)\" echo \"- Database Server (Private): $DB_INSTANCE ($DB_PRIVATE_IP)\" echo \"\" echo \"Note: To connect to the web server: ssh -i ${KEY_NAME}.pem ec2-user@ $WEB_PUBLIC_IP\" echo \"To connect to the database server, you must first connect to the web server, then use it as a bastion host.\" echo \"===========================================\" echo \"CLEANUP CONFIRMATION\" echo \"===========================================\" echo \"Do you want to clean up all created resources? (y/n): \" read -r CLEANUP_CHOICE if [[ \"$CLEANUP_CHOICE\" =~ ^[Yy]$ ]]; then echo \"Cleaning up resources...\" cleanup_resources echo \"All resources have been cleaned up.\" else echo \"Resources will not be cleaned up. You can manually clean them up later.\" fi echo \"Script completed at $(date)\" • API 세부 정보는 AWS CLI 명령 참조의 다음 토픽을 참조하세요. • AllocateAddress • AssociateRouteTable • AttachInternetGateway • AuthorizeSecurityGroupIngress • CreateInternetGateway • CreateKeyPair Amazon VPC 시작하기 1417\n\n Amazon Elastic Compute Cloud 개발자 안내서 • CreateNatGateway • CreateRoute • CreateRouteTable • CreateSecurityGroup • CreateSubnet • CreateVpc • DeleteInternetGateway • DeleteKeyPair • DeleteNatGateway • DeleteRouteTable • DeleteSecurityGroup • DeleteSubnet • DeleteVpc • DescribeAvailabilityZones • DescribeImages • DescribeInstances • DescribeInternetGateways • DescribeNatGateways • DescribeRouteTables • DescribeSecurityGroups • DescribeSubnets • DescribeVpcs • DetachInternetGateway • DisassociateRouteTable • ModifySubnetAttribute • ModifyVpcAttribute • ReleaseAddress • RunInstances • TerminateInstances Amazon VPC 시작하기 1418\n\n Amazon Elastic Compute Cloud 개발자 안내서 AWS SDK 개발자 안내서 및 코드 예제의 전체 목록은 섹션을 참조하세요AWS SDK를 사용하여 Amazon EC2 리소스 생성. 이 주제에는 시작하기에 대한 정보와 이전 SDK 버전에 대한 세부 정보도 포함되어 있습니다. CLI를 사용하여 Transit Gateway 시작하기 다음 코드 예제는 다음과 같은 작업을 수행하는 방법을 보여줍니다. • DNS 지원 및 기본 라우팅 테이블 설정을 사용하여 Transit Gateway 생성 • Transit Gateway를 사용할 수 있을 때까지 대기 • 서브넷을 사용하여 Transit Gateway에 두 개의 VPC 연결 • VPC 연결을 사용할 수 있을 때까지 대기 • Transit Gateway와 VPC 사이에 경로 추가 • VPC 리소스 간 연결 테스트 • 경로, 연결 및 Transit Gateway를 포함한 리소스 정리 Bash AWS CLI Bash 스크립트 사용 Note GitHub에 더 많은 내용이 있습니다. 샘플 개발자 튜토리얼 리포지토리에서 전체 예제를 찾아보고 설정 및 실행 방법을 배워보세요. #!/bin/bash # Amazon VPC Transit Gateway CLI Script # This script demonstrates how to create a transit gateway and connect two VPCs # Modified to work with older AWS CLI versions that don't support transit gateway wait commands # Error handling set -e LOG_FILE=\"transit-gateway-tutorial.log\" exec > >(tee -a \"$LOG_FILE\") 2>&1 # Function to wait for transit gateway to be available Transit Gateway 시작하기 1419\n\n Amazon Elastic Compute Cloud wait_for_tgw() { 개발자 안내서 local tgw_id=$1 echo \"Waiting for Transit Gateway $tgw_id to become available...\" while true; do status=$(aws ec2 describe-transit-gateways --transit-gateway-ids \"$tgw_id\" -- query \"TransitGateways[0].State\" --output text) echo \"Current status: $status\" if [ \"$status\" = \"available\" ]; then echo \"Transit Gateway is now available\" break fi echo \"Waiting for transit gateway to become available. Current state: $status\" sleep 10 done } # Function to wait for transit gateway attachment to be available wait_for_tgw_attachment() { local attachment_id=$1 echo \"Waiting for Transit Gateway Attachment $attachment_id to become available...\" while true; do status=$(aws ec2 describe-transit-gateway-vpc-attachments --transit-gateway- attachment-ids \"$attachment_id\" --query \"TransitGatewayVpcAttachments[0].State\" --output text) echo \"Current status: $status\" if [ \"$status\" = \"available\" ]; then echo \"Transit Gateway Attachment is now available\" break fi echo \"Waiting for transit gateway attachment to become available. Current state: $status\" sleep 10 done } # Function to wait for transit gateway attachment to be deleted Transit Gateway 시작하기 1420\n\n Amazon Elastic Compute Cloud 개발자 안내서 wait_for_tgw_attachment_deleted() { local attachment_id=$1 echo \"Waiting for Transit Gateway Attachment $attachment_id to be deleted...\" while true; do # Check if the attachment still exists count=$(aws ec2 describe-transit-gateway-vpc-attachments --filters \"Name=transit-gateway-attachment-id,Values=$attachment_id\" --query \"length(TransitGatewayVpcAttachments)\" --output text) if [ \"$count\" = \"0\" ]; then echo \"Transit Gateway Attachment has been deleted\" break fi status=$(aws ec2 describe-transit-gateway-vpc-attachments --transit-gateway- attachment-ids \"$attachment_id\" --query \"TransitGatewayVpcAttachments[0].State\" --output text"}], "answer": "### 새로운 서버 생성하는 법\n\n새로운 서버를 생성하는 방법에 대해 설명드리겠습니다.\n\n#### 서론\n\nAWS GameLift는 게임 서버를 호스팅하고 관리하는 서비스입니다. GameLift를 사용하여 게임 서버를 생성, 관리, 및 배포할 수 있습니다. 이 문서에서는 GameLift를 사용하여 새로운 서버를 생성하는 방법에 대해 설명드리겠습니다.\n\n#### 본론\n\n새로운 서버를 생성하는 방법은 다음과 같습니다.\n\n1.  **GameLift 계정 생성**: GameLift 계정을 생성하여 게임 서버를 호스팅할 수 있습니다. GameLift 계정은 AWS 계정과 연동됩니다.\n2.  **빌드 생성**: 게임 서버를 호스팅하기 위한 빌드를 생성합니다. 빌드는 게임 서버의 소프트웨어와 설정을 포함합니다.\n3.  **플릿 생성**: 빌드를 호스팅하기 위한 플릿을 생성합니다. 플릿은 게임 서버를 호스팅하는 인스턴스 그룹입니다.\n4.  **게임 세션 대기열 생성**: 게임 서버를 호스팅하기 위한 게임 세션 대기열을 생성합니다. 게임 세션 대기열은 게임 서버를 호스팅하는 대기열입니다.\n\n#### 플릿 생성\n\n플릿을 생성하는 방법은 다음과 같습니다.\n\n1.  **create-fleet 명령**: `create-fleet` 명령을 사용하여 플릿을 생성합니다. `create-fleet` 명령은 플릿의 이름, 설명, 빌드 ID, 인스턴스 유형, 플릿 유형, 런타임 구성, 인증서 구성, 및 기타 설정을 지정합니다.\n2.  **플릿 속성 확인**: `update-fleet` 명령을 사용하여 플릿의 속성을 확인합니다. `update-fleet` 명령은 플릿의 이름, 설명, 빌드 ID, 인스턴스 유형, 플릿 유형, 런타임 구성, 인증서 구성, 및 기타 설정을 확인합니다.\n\n#### 게임 세션 대기열 생성\n\n게임 세션 대기열을 생성하는 방법은 다음과 같습니다.\n\n1.  **create-game-session-queue 명령**: `create-game-session-queue` 명령을 사용하여 게임 세션 대기열을 생성합니다. `create-game-session-queue` 명령은 게임 세션 대기열의 이름, 설명, 대상, 시간 초과, 플레이어 지연 시간 정책, 및 기타 설정을 지정합니다.\n2.  **게임 세션 대기열 속성 확인**: `describe-game-session-queue` 명령을 사용하여 게임 세션 대기열의 속성을 확인합니다. `describe-game-session-queue` 명령은 게임 세션 대기열의 이름, 설명, 대상, 시간 초과, 플레이어 지연 시간 정책, 및 기타 설정을 확인합니다.\n\n#### 예시\n\n다음은 `create-fleet` 명령과 `create-game-session-queue` 명령의 예시입니다.\n\n```bash\naws gamelift create-fleet \\\n  --name MegaFrogRaceServer.NA.v2 \\\n  --description 'Hosts for v2 North America' \\\n  --build-id build-1111aaaa-22bb-33cc-44dd-5555eeee66ff \\\n  --certificate-configuration 'CertificateType=GENERATED' \\\n  --ec2-instance-type c4.large \\\n  --fleet-type ON_DEMAND \\\n  --runtime-configuration 'ServerProcesses=[{LaunchPath=/local/game/release-na/MegaFrogRace_Server.exe,ConcurrentExecutions=1}]'\n\naws gamelift create-game-session-queue \\\n  --name MegaFrogRaceServer-NA \\\n  --destinations file://destinations.json \\\n  --timeout-in-seconds 600\n```\n\n#### 결론\n\n새로운 서버를 생성하는 방법은 GameLift 계정, 빌드, 플릿, 및 게임 세션 대기열을 생성하는 것입니다. `create-fleet` 명령과 `create-game-session-queue` 명령을 사용하여 플릿과 게임 세션 대기열을 생성할 수 있습니다. 게임 서버를 호스팅하기 위한 빌드를 생성하고, 플릿을 생성하여 게임 서버를 호스팅할 수 있습니다. 게임 세션 대기열을 생성하여 게임 서버를 호스팅할 수 있습니다.\n\n### 도움이 필요하신가요?\n\n게임 서버를 호스팅하기 위한 도움이 필요하신가요? GameLift를 사용하여 게임 서버를 호스팅하고 관리할 수 있습니다. GameLift 계정, 빌드, 플릿, 및 게임 세션 대기열을 생성하여 게임 서버를 호스팅할 수 있습니다. 게임 서버를 호스팅하기 위한 도움이 필요하신가요? GameLift를 사용하여 게임 서버를 호스팅하고 관리할 수 있습니다. GameLift 계정, 빌드, 플릿, 및 게임 세션 대기열을 생성하여 게임 서버를 호스팅할 수 있습니다."}
